/* automatically generated by rust-bindgen 0.72.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
#[derive(PartialEq, Copy, Clone, Hash, Debug, Default)]
#[repr(C)]
pub struct __BindgenComplex<T> {
    pub re: T,
    pub im: T,
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_KERNELKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_13_7: u32 = 130700;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_14_6: u32 = 140600;
pub const __MAC_14_7: u32 = 140700;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __MAC_15_3: u32 = 150300;
pub const __MAC_15_4: u32 = 150400;
pub const __MAC_15_5: u32 = 150500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_17_6: u32 = 170600;
pub const __IPHONE_17_7: u32 = 170700;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __IPHONE_18_3: u32 = 180300;
pub const __IPHONE_18_4: u32 = 180400;
pub const __IPHONE_18_5: u32 = 180500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_10_6: u32 = 100600;
pub const __WATCHOS_10_7: u32 = 100700;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __WATCHOS_11_3: u32 = 110300;
pub const __WATCHOS_11_4: u32 = 110400;
pub const __WATCHOS_11_5: u32 = 110500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_17_6: u32 = 170600;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __TVOS_18_3: u32 = 180300;
pub const __TVOS_18_4: u32 = 180400;
pub const __TVOS_18_5: u32 = 180500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_8_6: u32 = 80600;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __BRIDGEOS_9_3: u32 = 90300;
pub const __BRIDGEOS_9_4: u32 = 90400;
pub const __BRIDGEOS_9_5: u32 = 90500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_23_6: u32 = 230600;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __DRIVERKIT_24_3: u32 = 240300;
pub const __DRIVERKIT_24_4: u32 = 240400;
pub const __DRIVERKIT_24_5: u32 = 240500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_1_3: u32 = 10300;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const __VISIONOS_2_3: u32 = 20300;
pub const __VISIONOS_2_4: u32 = 20400;
pub const __VISIONOS_2_5: u32 = 20500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_13_7: u32 = 130700;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_14_6: u32 = 140600;
pub const MAC_OS_VERSION_14_7: u32 = 140700;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const MAC_OS_VERSION_15_3: u32 = 150300;
pub const MAC_OS_VERSION_15_4: u32 = 150400;
pub const MAC_OS_VERSION_15_5: u32 = 150500;
pub const __AVAILABILITY_VERSIONS_VERSION_HASH: u32 = 93585900;
pub const __AVAILABILITY_VERSIONS_VERSION_STRING: &[u8; 6] = b"Local\0";
pub const __AVAILABILITY_FILE: &[u8; 23] = b"AvailabilityVersions.h\0";
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE: u32 = 2;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const QISKIT_RELEASE_LEVEL_DEV: u32 = 10;
pub const QISKIT_RELEASE_LEVEL_BETA: u32 = 11;
pub const QISKIT_RELEASE_LEVEL_RC: u32 = 12;
pub const QISKIT_RELEASE_LEVEL_FINAL: u32 = 15;
pub const QISKIT_VERSION_MAJOR: u32 = 2;
pub const QISKIT_VERSION_MINOR: u32 = 3;
pub const QISKIT_VERSION_PATCH: u32 = 0;
pub const QISKIT_RELEASE_LEVEL: u32 = 10;
pub const QISKIT_RELEASE_SERIAL: u32 = 0;
pub const QISKIT_VERSION: &[u8; 10] = b"2.3.0-dev\0";
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state"]
        [::std::mem::size_of::<__darwin_arm_exception_state>() - 12usize];
    ["Alignment of __darwin_arm_exception_state"]
        [::std::mem::align_of::<__darwin_arm_exception_state>() - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __exception) - 0usize];
    ["Offset of field: __darwin_arm_exception_state::__fsr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __fsr) - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state, __far) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64"]
        [::std::mem::size_of::<__darwin_arm_exception_state64>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64"]
        [::std::mem::align_of::<__darwin_arm_exception_state64>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __esr) - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__exception"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64, __exception) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64_v2 {
    pub __far: __uint64_t,
    pub __esr: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64_v2"]
        [::std::mem::size_of::<__darwin_arm_exception_state64_v2>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64_v2"]
        [::std::mem::align_of::<__darwin_arm_exception_state64_v2>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__far"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__esr"]
        [::std::mem::offset_of!(__darwin_arm_exception_state64_v2, __esr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state"]
        [::std::mem::size_of::<__darwin_arm_thread_state>() - 68usize];
    ["Alignment of __darwin_arm_thread_state"]
        [::std::mem::align_of::<__darwin_arm_thread_state>() - 4usize];
    ["Offset of field: __darwin_arm_thread_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_thread_state::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __sp) - 52usize];
    ["Offset of field: __darwin_arm_thread_state::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __lr) - 56usize];
    ["Offset of field: __darwin_arm_thread_state::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __pc) - 60usize];
    ["Offset of field: __darwin_arm_thread_state::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state, __cpsr) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state64"]
        [::std::mem::size_of::<__darwin_arm_thread_state64>() - 272usize];
    ["Alignment of __darwin_arm_thread_state64"]
        [::std::mem::align_of::<__darwin_arm_thread_state64>() - 8usize];
    ["Offset of field: __darwin_arm_thread_state64::__x"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __x) - 0usize];
    ["Offset of field: __darwin_arm_thread_state64::__fp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __fp) - 232usize];
    ["Offset of field: __darwin_arm_thread_state64::__lr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __lr) - 240usize];
    ["Offset of field: __darwin_arm_thread_state64::__sp"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __sp) - 248usize];
    ["Offset of field: __darwin_arm_thread_state64::__pc"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pc) - 256usize];
    ["Offset of field: __darwin_arm_thread_state64::__cpsr"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __cpsr) - 264usize];
    ["Offset of field: __darwin_arm_thread_state64::__pad"]
        [::std::mem::offset_of!(__darwin_arm_thread_state64, __pad) - 268usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_vfp_state"][::std::mem::size_of::<__darwin_arm_vfp_state>() - 260usize];
    ["Alignment of __darwin_arm_vfp_state"]
        [::std::mem::align_of::<__darwin_arm_vfp_state>() - 4usize];
    ["Offset of field: __darwin_arm_vfp_state::__r"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_vfp_state::__fpscr"]
        [::std::mem::offset_of!(__darwin_arm_vfp_state, __fpscr) - 256usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state64"]
        [::std::mem::size_of::<__darwin_arm_neon_state64>() - 528usize];
    ["Alignment of __darwin_arm_neon_state64"]
        [::std::mem::align_of::<__darwin_arm_neon_state64>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state64::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpsr) - 512usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state64, __fpcr) - 516usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state"]
        [::std::mem::size_of::<__darwin_arm_neon_state>() - 272usize];
    ["Alignment of __darwin_arm_neon_state"]
        [::std::mem::align_of::<__darwin_arm_neon_state>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state::__v"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state::__fpsr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpsr) - 256usize];
    ["Offset of field: __darwin_arm_neon_state::__fpcr"]
        [::std::mem::offset_of!(__darwin_arm_neon_state, __fpcr) - 260usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_pagein_state"][::std::mem::size_of::<__arm_pagein_state>() - 4usize];
    ["Alignment of __arm_pagein_state"][::std::mem::align_of::<__arm_pagein_state>() - 4usize];
    ["Offset of field: __arm_pagein_state::__pagein_error"]
        [::std::mem::offset_of!(__arm_pagein_state, __pagein_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme_state {
    pub __svcr: __uint64_t,
    pub __tpidr2_el0: __uint64_t,
    pub __svl_b: __uint16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_state"][::std::mem::size_of::<__darwin_arm_sme_state>() - 24usize];
    ["Alignment of __darwin_arm_sme_state"]
        [::std::mem::align_of::<__darwin_arm_sme_state>() - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svcr"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svcr) - 0usize];
    ["Offset of field: __darwin_arm_sme_state::__tpidr2_el0"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __tpidr2_el0) - 8usize];
    ["Offset of field: __darwin_arm_sme_state::__svl_b"]
        [::std::mem::offset_of!(__darwin_arm_sme_state, __svl_b) - 16usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sve_z_state {
    pub __z: [[::std::os::raw::c_char; 256usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_z_state"]
        [::std::mem::size_of::<__darwin_arm_sve_z_state>() - 4096usize];
    ["Alignment of __darwin_arm_sve_z_state"]
        [::std::mem::align_of::<__darwin_arm_sve_z_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_z_state::__z"]
        [::std::mem::offset_of!(__darwin_arm_sve_z_state, __z) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sve_p_state {
    pub __p: [[::std::os::raw::c_char; 32usize]; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sve_p_state"]
        [::std::mem::size_of::<__darwin_arm_sve_p_state>() - 512usize];
    ["Alignment of __darwin_arm_sve_p_state"]
        [::std::mem::align_of::<__darwin_arm_sve_p_state>() - 4usize];
    ["Offset of field: __darwin_arm_sve_p_state::__p"]
        [::std::mem::offset_of!(__darwin_arm_sve_p_state, __p) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme_za_state {
    pub __za: [::std::os::raw::c_char; 4096usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme_za_state"]
        [::std::mem::size_of::<__darwin_arm_sme_za_state>() - 4096usize];
    ["Alignment of __darwin_arm_sme_za_state"]
        [::std::mem::align_of::<__darwin_arm_sme_za_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme_za_state::__za"]
        [::std::mem::offset_of!(__darwin_arm_sme_za_state, __za) - 0usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_sme2_state {
    pub __zt0: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_sme2_state"][::std::mem::size_of::<__darwin_arm_sme2_state>() - 64usize];
    ["Alignment of __darwin_arm_sme2_state"]
        [::std::mem::align_of::<__darwin_arm_sme2_state>() - 4usize];
    ["Offset of field: __darwin_arm_sme2_state::__zt0"]
        [::std::mem::offset_of!(__darwin_arm_sme2_state, __zt0) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_legacy_debug_state"]
        [::std::mem::size_of::<__arm_legacy_debug_state>() - 256usize];
    ["Alignment of __arm_legacy_debug_state"]
        [::std::mem::align_of::<__arm_legacy_debug_state>() - 4usize];
    ["Offset of field: __arm_legacy_debug_state::__bvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bvr) - 0usize];
    ["Offset of field: __arm_legacy_debug_state::__bcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __bcr) - 64usize];
    ["Offset of field: __arm_legacy_debug_state::__wvr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wvr) - 128usize];
    ["Offset of field: __arm_legacy_debug_state::__wcr"]
        [::std::mem::offset_of!(__arm_legacy_debug_state, __wcr) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state32"]
        [::std::mem::size_of::<__darwin_arm_debug_state32>() - 264usize];
    ["Alignment of __darwin_arm_debug_state32"]
        [::std::mem::align_of::<__darwin_arm_debug_state32>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state32::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state32::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __bcr) - 64usize];
    ["Offset of field: __darwin_arm_debug_state32::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wvr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state32::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __wcr) - 192usize];
    ["Offset of field: __darwin_arm_debug_state32::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state32, __mdscr_el1) - 256usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state64"]
        [::std::mem::size_of::<__darwin_arm_debug_state64>() - 520usize];
    ["Alignment of __darwin_arm_debug_state64"]
        [::std::mem::align_of::<__darwin_arm_debug_state64>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state64::__bvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state64::__bcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __bcr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state64::__wvr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wvr) - 256usize];
    ["Offset of field: __darwin_arm_debug_state64::__wcr"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __wcr) - 384usize];
    ["Offset of field: __darwin_arm_debug_state64::__mdscr_el1"]
        [::std::mem::offset_of!(__darwin_arm_debug_state64, __mdscr_el1) - 512usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_cpmu_state64"]
        [::std::mem::size_of::<__darwin_arm_cpmu_state64>() - 128usize];
    ["Alignment of __darwin_arm_cpmu_state64"]
        [::std::mem::align_of::<__darwin_arm_cpmu_state64>() - 8usize];
    ["Offset of field: __darwin_arm_cpmu_state64::__ctrs"]
        [::std::mem::offset_of!(__darwin_arm_cpmu_state64, __ctrs) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext32"][::std::mem::size_of::<__darwin_mcontext32>() - 340usize];
    ["Alignment of __darwin_mcontext32"][::std::mem::align_of::<__darwin_mcontext32>() - 4usize];
    ["Offset of field: __darwin_mcontext32::__es"]
        [::std::mem::offset_of!(__darwin_mcontext32, __es) - 0usize];
    ["Offset of field: __darwin_mcontext32::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext32, __ss) - 12usize];
    ["Offset of field: __darwin_mcontext32::__fs"]
        [::std::mem::offset_of!(__darwin_mcontext32, __fs) - 80usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext64"][::std::mem::size_of::<__darwin_mcontext64>() - 816usize];
    ["Alignment of __darwin_mcontext64"][::std::mem::align_of::<__darwin_mcontext64>() - 16usize];
    ["Offset of field: __darwin_mcontext64::__es"]
        [::std::mem::offset_of!(__darwin_mcontext64, __es) - 0usize];
    ["Offset of field: __darwin_mcontext64::__ss"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ss) - 16usize];
    ["Offset of field: __darwin_mcontext64::__ns"]
        [::std::mem::offset_of!(__darwin_mcontext64, __ns) - 288usize];
};
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_sigaltstack"][::std::mem::size_of::<__darwin_sigaltstack>() - 24usize];
    ["Alignment of __darwin_sigaltstack"][::std::mem::align_of::<__darwin_sigaltstack>() - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_sp"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_sp) - 0usize];
    ["Offset of field: __darwin_sigaltstack::ss_size"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_size) - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_flags"]
        [::std::mem::offset_of!(__darwin_sigaltstack, ss_flags) - 16usize];
};
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_ucontext"][::std::mem::size_of::<__darwin_ucontext>() - 56usize];
    ["Alignment of __darwin_ucontext"][::std::mem::align_of::<__darwin_ucontext>() - 8usize];
    ["Offset of field: __darwin_ucontext::uc_onstack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_onstack) - 0usize];
    ["Offset of field: __darwin_ucontext::uc_sigmask"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_sigmask) - 4usize];
    ["Offset of field: __darwin_ucontext::uc_stack"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_stack) - 8usize];
    ["Offset of field: __darwin_ucontext::uc_link"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_link) - 32usize];
    ["Offset of field: __darwin_ucontext::uc_mcsize"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcsize) - 40usize];
    ["Offset of field: __darwin_ucontext::uc_mcontext"]
        [::std::mem::offset_of!(__darwin_ucontext, uc_mcontext) - 48usize];
};
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 32usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 4usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 8usize];
    ["Offset of field: sigevent::sigev_notify_function"]
        [::std::mem::offset_of!(sigevent, sigev_notify_function) - 16usize];
    ["Offset of field: sigevent::sigev_notify_attributes"]
        [::std::mem::offset_of!(sigevent, sigev_notify_attributes) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __siginfo"][::std::mem::size_of::<__siginfo>() - 104usize];
    ["Alignment of __siginfo"][::std::mem::align_of::<__siginfo>() - 8usize];
    ["Offset of field: __siginfo::si_signo"][::std::mem::offset_of!(__siginfo, si_signo) - 0usize];
    ["Offset of field: __siginfo::si_errno"][::std::mem::offset_of!(__siginfo, si_errno) - 4usize];
    ["Offset of field: __siginfo::si_code"][::std::mem::offset_of!(__siginfo, si_code) - 8usize];
    ["Offset of field: __siginfo::si_pid"][::std::mem::offset_of!(__siginfo, si_pid) - 12usize];
    ["Offset of field: __siginfo::si_uid"][::std::mem::offset_of!(__siginfo, si_uid) - 16usize];
    ["Offset of field: __siginfo::si_status"]
        [::std::mem::offset_of!(__siginfo, si_status) - 20usize];
    ["Offset of field: __siginfo::si_addr"][::std::mem::offset_of!(__siginfo, si_addr) - 24usize];
    ["Offset of field: __siginfo::si_value"][::std::mem::offset_of!(__siginfo, si_value) - 32usize];
    ["Offset of field: __siginfo::si_band"][::std::mem::offset_of!(__siginfo, si_band) - 40usize];
    ["Offset of field: __siginfo::__pad"][::std::mem::offset_of!(__siginfo, __pad) - 48usize];
};
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction_u"][::std::mem::size_of::<__sigaction_u>() - 8usize];
    ["Alignment of __sigaction_u"][::std::mem::align_of::<__sigaction_u>() - 8usize];
    ["Offset of field: __sigaction_u::__sa_handler"]
        [::std::mem::offset_of!(__sigaction_u, __sa_handler) - 0usize];
    ["Offset of field: __sigaction_u::__sa_sigaction"]
        [::std::mem::offset_of!(__sigaction_u, __sa_sigaction) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction"][::std::mem::size_of::<__sigaction>() - 24usize];
    ["Alignment of __sigaction"][::std::mem::align_of::<__sigaction>() - 8usize];
    ["Offset of field: __sigaction::__sigaction_u"]
        [::std::mem::offset_of!(__sigaction, __sigaction_u) - 0usize];
    ["Offset of field: __sigaction::sa_tramp"]
        [::std::mem::offset_of!(__sigaction, sa_tramp) - 8usize];
    ["Offset of field: __sigaction::sa_mask"]
        [::std::mem::offset_of!(__sigaction, sa_mask) - 16usize];
    ["Offset of field: __sigaction::sa_flags"]
        [::std::mem::offset_of!(__sigaction, sa_flags) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 16usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_u"]
        [::std::mem::offset_of!(sigaction, __sigaction_u) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"][::std::mem::offset_of!(sigaction, sa_flags) - 12usize];
};
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigvec"][::std::mem::size_of::<sigvec>() - 16usize];
    ["Alignment of sigvec"][::std::mem::align_of::<sigvec>() - 8usize];
    ["Offset of field: sigvec::sv_handler"][::std::mem::offset_of!(sigvec, sv_handler) - 0usize];
    ["Offset of field: sigvec::sv_mask"][::std::mem::offset_of!(sigvec, sv_mask) - 8usize];
    ["Offset of field: sigvec::sv_flags"][::std::mem::offset_of!(sigvec, sv_flags) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage"][::std::mem::size_of::<rusage>() - 144usize];
    ["Alignment of rusage"][::std::mem::align_of::<rusage>() - 8usize];
    ["Offset of field: rusage::ru_utime"][::std::mem::offset_of!(rusage, ru_utime) - 0usize];
    ["Offset of field: rusage::ru_stime"][::std::mem::offset_of!(rusage, ru_stime) - 16usize];
    ["Offset of field: rusage::ru_maxrss"][::std::mem::offset_of!(rusage, ru_maxrss) - 32usize];
    ["Offset of field: rusage::ru_ixrss"][::std::mem::offset_of!(rusage, ru_ixrss) - 40usize];
    ["Offset of field: rusage::ru_idrss"][::std::mem::offset_of!(rusage, ru_idrss) - 48usize];
    ["Offset of field: rusage::ru_isrss"][::std::mem::offset_of!(rusage, ru_isrss) - 56usize];
    ["Offset of field: rusage::ru_minflt"][::std::mem::offset_of!(rusage, ru_minflt) - 64usize];
    ["Offset of field: rusage::ru_majflt"][::std::mem::offset_of!(rusage, ru_majflt) - 72usize];
    ["Offset of field: rusage::ru_nswap"][::std::mem::offset_of!(rusage, ru_nswap) - 80usize];
    ["Offset of field: rusage::ru_inblock"][::std::mem::offset_of!(rusage, ru_inblock) - 88usize];
    ["Offset of field: rusage::ru_oublock"][::std::mem::offset_of!(rusage, ru_oublock) - 96usize];
    ["Offset of field: rusage::ru_msgsnd"][::std::mem::offset_of!(rusage, ru_msgsnd) - 104usize];
    ["Offset of field: rusage::ru_msgrcv"][::std::mem::offset_of!(rusage, ru_msgrcv) - 112usize];
    ["Offset of field: rusage::ru_nsignals"]
        [::std::mem::offset_of!(rusage, ru_nsignals) - 120usize];
    ["Offset of field: rusage::ru_nvcsw"][::std::mem::offset_of!(rusage, ru_nvcsw) - 128usize];
    ["Offset of field: rusage::ru_nivcsw"][::std::mem::offset_of!(rusage, ru_nivcsw) - 136usize];
};
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v0"][::std::mem::size_of::<rusage_info_v0>() - 96usize];
    ["Alignment of rusage_info_v0"][::std::mem::align_of::<rusage_info_v0>() - 8usize];
    ["Offset of field: rusage_info_v0::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v0, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v0::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v0::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v0, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v0::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v0::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v0, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v0::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v0, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v0::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v0::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v0, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v0::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v0, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v0::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v0::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v0, ri_proc_exit_abstime) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v1"][::std::mem::size_of::<rusage_info_v1>() - 144usize];
    ["Alignment of rusage_info_v1"][::std::mem::align_of::<rusage_info_v1>() - 8usize];
    ["Offset of field: rusage_info_v1::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v1, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v1::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v1::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v1::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v1::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v1::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v1::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v1::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v1, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v1::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v1, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v1::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v1::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v1::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v1::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v1::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v1::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v1::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v1::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v1, ri_child_elapsed_abstime) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v2"][::std::mem::size_of::<rusage_info_v2>() - 160usize];
    ["Alignment of rusage_info_v2"][::std::mem::align_of::<rusage_info_v2>() - 8usize];
    ["Offset of field: rusage_info_v2::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v2, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v2::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v2::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v2::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v2::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v2::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v2::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v2::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v2, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v2::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v2, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v2::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v2::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v2::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v2::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v2::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v2::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v2::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v2::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v2, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v2::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v2::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v2, ri_diskio_byteswritten) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v3"][::std::mem::size_of::<rusage_info_v3>() - 232usize];
    ["Alignment of rusage_info_v3"][::std::mem::align_of::<rusage_info_v3>() - 8usize];
    ["Offset of field: rusage_info_v3::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v3, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v3::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v3::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v3::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v3::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v3::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v3::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v3::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v3, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v3::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v3, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v3::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v3::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v3::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v3::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v3::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v3::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v3::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v3::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v3, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v3::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v3::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v3, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v3::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v3::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v3, ri_serviced_system_time) - 224usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v4"][::std::mem::size_of::<rusage_info_v4>() - 296usize];
    ["Alignment of rusage_info_v4"][::std::mem::align_of::<rusage_info_v4>() - 8usize];
    ["Offset of field: rusage_info_v4::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v4, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v4::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v4::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v4::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v4::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v4::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v4::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v4::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v4, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v4::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v4::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v4::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v4::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v4::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v4::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v4::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v4::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v4::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v4, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v4::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v4::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v4, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v4::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v4::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v4::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v4, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v4::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v4::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v4, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v4::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v4, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v4::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v4::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v4, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v4::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v4, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v4::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v4, ri_runnable_time) - 288usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v5"][::std::mem::size_of::<rusage_info_v5>() - 304usize];
    ["Alignment of rusage_info_v5"][::std::mem::align_of::<rusage_info_v5>() - 8usize];
    ["Offset of field: rusage_info_v5::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v5, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v5::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v5::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v5::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v5::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v5::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v5::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v5::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v5, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v5::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v5::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v5::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v5::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v5::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v5::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v5::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v5::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v5::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v5, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v5::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v5::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v5, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v5::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v5::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v5::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v5, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v5::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v5::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v5, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v5::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v5, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v5::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v5::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v5, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v5::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v5, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v5::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v5, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v5::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v5, ri_flags) - 296usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_neural_footprint: u64,
    pub ri_lifetime_max_neural_footprint: u64,
    pub ri_interval_max_neural_footprint: u64,
    pub ri_reserved: [u64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v6"][::std::mem::size_of::<rusage_info_v6>() - 464usize];
    ["Alignment of rusage_info_v6"][::std::mem::align_of::<rusage_info_v6>() - 8usize];
    ["Offset of field: rusage_info_v6::ri_uuid"]
        [::std::mem::offset_of!(rusage_info_v6, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v6::ri_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v6::ri_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v6::ri_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v6::ri_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v6::ri_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v6::ri_wired_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v6::ri_resident_size"]
        [::std::mem::offset_of!(rusage_info_v6, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v6::ri_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v6::ri_proc_start_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v6::ri_proc_exit_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v6::ri_child_user_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v6::ri_child_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v6::ri_child_pkg_idle_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v6::ri_child_interrupt_wkups"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v6::ri_child_pageins"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v6::ri_child_elapsed_abstime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v6::ri_diskio_bytesread"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v6::ri_diskio_byteswritten"]
        [::std::mem::offset_of!(rusage_info_v6, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_default"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_maintenance"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_background"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_utility"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_legacy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_initiated"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_interactive"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v6::ri_billed_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v6::ri_serviced_system_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v6::ri_logical_writes"]
        [::std::mem::offset_of!(rusage_info_v6, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v6::ri_instructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v6::ri_cycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v6::ri_billed_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v6::ri_serviced_energy"]
        [::std::mem::offset_of!(rusage_info_v6, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_phys_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v6::ri_runnable_time"]
        [::std::mem::offset_of!(rusage_info_v6, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v6::ri_flags"]
        [::std::mem::offset_of!(rusage_info_v6, ri_flags) - 296usize];
    ["Offset of field: rusage_info_v6::ri_user_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_user_ptime) - 304usize];
    ["Offset of field: rusage_info_v6::ri_system_ptime"]
        [::std::mem::offset_of!(rusage_info_v6, ri_system_ptime) - 312usize];
    ["Offset of field: rusage_info_v6::ri_pinstructions"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pinstructions) - 320usize];
    ["Offset of field: rusage_info_v6::ri_pcycles"]
        [::std::mem::offset_of!(rusage_info_v6, ri_pcycles) - 328usize];
    ["Offset of field: rusage_info_v6::ri_energy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_energy_nj) - 336usize];
    ["Offset of field: rusage_info_v6::ri_penergy_nj"]
        [::std::mem::offset_of!(rusage_info_v6, ri_penergy_nj) - 344usize];
    ["Offset of field: rusage_info_v6::ri_secure_time_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_time_in_system) - 352usize];
    ["Offset of field: rusage_info_v6::ri_secure_ptime_in_system"]
        [::std::mem::offset_of!(rusage_info_v6, ri_secure_ptime_in_system) - 360usize];
    ["Offset of field: rusage_info_v6::ri_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_neural_footprint) - 368usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_lifetime_max_neural_footprint) - 376usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_neural_footprint"]
        [::std::mem::offset_of!(rusage_info_v6, ri_interval_max_neural_footprint) - 384usize];
    ["Offset of field: rusage_info_v6::ri_reserved"]
        [::std::mem::offset_of!(rusage_info_v6, ri_reserved) - 392usize];
};
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rlimit"][::std::mem::size_of::<rlimit>() - 16usize];
    ["Alignment of rlimit"][::std::mem::align_of::<rlimit>() - 8usize];
    ["Offset of field: rlimit::rlim_cur"][::std::mem::offset_of!(rlimit, rlim_cur) - 0usize];
    ["Offset of field: rlimit::rlim_max"][::std::mem::offset_of!(rlimit, rlim_max) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of proc_rlimit_control_wakeupmon"]
        [::std::mem::size_of::<proc_rlimit_control_wakeupmon>() - 8usize];
    ["Alignment of proc_rlimit_control_wakeupmon"]
        [::std::mem::align_of::<proc_rlimit_control_wakeupmon>() - 4usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_flags"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_flags) - 0usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_rate"]
        [::std::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_rate) - 4usize];
};
unsafe extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_1"][::std::mem::size_of::<wait__bindgen_ty_1>() - 4usize];
    ["Alignment of wait__bindgen_ty_1"][::std::mem::align_of::<wait__bindgen_ty_1>() - 4usize];
};
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Termsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Termsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Coredump_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Coredump_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Retcode_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Retcode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_2"][::std::mem::size_of::<wait__bindgen_ty_2>() - 4usize];
    ["Alignment of wait__bindgen_ty_2"][::std::mem::align_of::<wait__bindgen_ty_2>() - 4usize];
};
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopval_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopval_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait"][::std::mem::size_of::<wait>() - 4usize];
    ["Alignment of wait"][::std::mem::align_of::<wait>() - 4usize];
    ["Offset of field: wait::w_status"][::std::mem::offset_of!(wait, w_status) - 0usize];
    ["Offset of field: wait::w_T"][::std::mem::offset_of!(wait, w_T) - 0usize];
    ["Offset of field: wait::w_S"][::std::mem::offset_of!(wait, w_S) - 0usize];
};
unsafe extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
unsafe extern "C" {
    pub fn malloc_type_malloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
unsafe extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_valloc(
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::std::os::raw::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
unsafe extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        type_id: malloc_type_id_t,
    );
}
unsafe extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        __size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
unsafe extern "C" {
    pub fn arc4random() -> u32;
}
unsafe extern "C" {
    pub fn arc4random_addrandom(
        arg1: *mut ::std::os::raw::c_uchar,
        __datlen: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
unsafe extern "C" {
    pub fn arc4random_stir();
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
unsafe extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getloadavg(arg1: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sranddev();
}
unsafe extern "C" {
    pub fn srandomdev();
}
unsafe extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
#[doc = " A complex double.\n\n See also ``qk_complex64_to_native`` and ``qk_complex64_from_native`` to convert\n this struct to (or from) a compiler-native complex number representation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkComplex64 {
    pub re: f64,
    pub im: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkComplex64"][::std::mem::size_of::<QkComplex64>() - 16usize];
    ["Alignment of QkComplex64"][::std::mem::align_of::<QkComplex64>() - 8usize];
    ["Offset of field: QkComplex64::re"][::std::mem::offset_of!(QkComplex64, re) - 0usize];
    ["Offset of field: QkComplex64::im"][::std::mem::offset_of!(QkComplex64, im) - 8usize];
};
unsafe extern "C" {
    pub fn cacosf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cacos(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cacosl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn casinf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn casin(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn casinl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn catanf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn catan(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn catanl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn ccosf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ccos(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ccosl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn csinf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn csin(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csinl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn ctanf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ctan(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ctanl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn cacoshf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cacosh(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cacoshl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn casinhf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn casinh(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn casinhl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn catanhf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn catanh(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn catanhl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn ccoshf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ccosh(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ccoshl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn csinhf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn csinh(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csinhl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn ctanhf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn ctanh(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn ctanhl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn cexpf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cexp(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cexpl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn clogf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn clog(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn clogl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn cabsf(arg1: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn cabs(arg1: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn cabsl(arg1: __BindgenComplex<u128>) -> f64;
}
unsafe extern "C" {
    pub fn cpowf(arg1: __BindgenComplex<f32>, arg2: __BindgenComplex<f32>)
    -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cpow(arg1: __BindgenComplex<f64>, arg2: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cpowl(
        arg1: __BindgenComplex<u128>,
        arg2: __BindgenComplex<u128>,
    ) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn csqrtf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn csqrt(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn csqrtl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn cargf(arg1: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn carg(arg1: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn cargl(arg1: __BindgenComplex<u128>) -> f64;
}
unsafe extern "C" {
    pub fn cimagf(arg1: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn cimag(arg1: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn cimagl(arg1: __BindgenComplex<u128>) -> f64;
}
unsafe extern "C" {
    pub fn conjf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn conj(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn conjl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn cprojf(arg1: __BindgenComplex<f32>) -> __BindgenComplex<f32>;
}
unsafe extern "C" {
    pub fn cproj(arg1: __BindgenComplex<f64>) -> __BindgenComplex<f64>;
}
unsafe extern "C" {
    pub fn cprojl(arg1: __BindgenComplex<u128>) -> __BindgenComplex<u128>;
}
unsafe extern "C" {
    pub fn crealf(arg1: __BindgenComplex<f32>) -> f32;
}
unsafe extern "C" {
    pub fn creal(arg1: __BindgenComplex<f64>) -> f64;
}
unsafe extern "C" {
    pub fn creall(arg1: __BindgenComplex<u128>) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkQuantumRegister {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkClassicalRegister {
    _unused: [u8; 0],
}
#[doc = " Pauli X operator."]
pub const QkBitTerm_QkBitTerm_X: QkBitTerm = 2;
#[doc = " Projector to the positive eigenstate of Pauli X."]
pub const QkBitTerm_QkBitTerm_Plus: QkBitTerm = 10;
#[doc = " Projector to the negative eigenstate of Pauli X."]
pub const QkBitTerm_QkBitTerm_Minus: QkBitTerm = 6;
#[doc = " Pauli Y operator."]
pub const QkBitTerm_QkBitTerm_Y: QkBitTerm = 3;
#[doc = " Projector to the positive eigenstate of Pauli Y."]
pub const QkBitTerm_QkBitTerm_Right: QkBitTerm = 11;
#[doc = " Projector to the negative eigenstate of Pauli Y."]
pub const QkBitTerm_QkBitTerm_Left: QkBitTerm = 7;
#[doc = " Pauli Z operator."]
pub const QkBitTerm_QkBitTerm_Z: QkBitTerm = 1;
#[doc = " Projector to the positive eigenstate of Pauli Z."]
pub const QkBitTerm_QkBitTerm_Zero: QkBitTerm = 9;
#[doc = " Projector to the negative eigenstate of Pauli Z."]
pub const QkBitTerm_QkBitTerm_One: QkBitTerm = 5;
pub type QkBitTerm = u8;
#[doc = " Success."]
pub const QkExitCode_QkExitCode_Success: QkExitCode = 0;
#[doc = " Error related to data input."]
pub const QkExitCode_QkExitCode_CInputError: QkExitCode = 100;
#[doc = " Unexpected null pointer."]
pub const QkExitCode_QkExitCode_NullPointerError: QkExitCode = 101;
#[doc = " Pointer is not aligned to expected data."]
pub const QkExitCode_QkExitCode_AlignmentError: QkExitCode = 102;
#[doc = " Index out of bounds."]
pub const QkExitCode_QkExitCode_IndexError: QkExitCode = 103;
#[doc = " Duplicate index."]
pub const QkExitCode_QkExitCode_DuplicateIndexError: QkExitCode = 104;
#[doc = " Error related to arithmetic operations or similar."]
pub const QkExitCode_QkExitCode_ArithmeticError: QkExitCode = 200;
#[doc = " Mismatching number of qubits."]
pub const QkExitCode_QkExitCode_MismatchedQubits: QkExitCode = 201;
#[doc = " Matrix is not unitary."]
pub const QkExitCode_QkExitCode_ExpectedUnitary: QkExitCode = 202;
#[doc = " Target related error"]
pub const QkExitCode_QkExitCode_TargetError: QkExitCode = 300;
#[doc = " Instruction already exists in the Target"]
pub const QkExitCode_QkExitCode_TargetInstAlreadyExists: QkExitCode = 301;
#[doc = " Properties with incorrect qargs was added"]
pub const QkExitCode_QkExitCode_TargetQargMismatch: QkExitCode = 302;
#[doc = " Trying to query into the target with non-existent qargs."]
pub const QkExitCode_QkExitCode_TargetInvalidQargsKey: QkExitCode = 303;
#[doc = " Querying an operation that doesn't exist in the Target."]
pub const QkExitCode_QkExitCode_TargetInvalidInstKey: QkExitCode = 304;
#[doc = " Transpilation failed"]
pub const QkExitCode_QkExitCode_TranspilerError: QkExitCode = 400;
pub type QkExitCode = u32;
#[doc = " Seconds."]
pub const QkDelayUnit_QkDelayUnit_S: QkDelayUnit = 0;
#[doc = " Milliseconds."]
pub const QkDelayUnit_QkDelayUnit_MS: QkDelayUnit = 1;
#[doc = " Microseconds."]
pub const QkDelayUnit_QkDelayUnit_US: QkDelayUnit = 2;
#[doc = " Nanoseconds."]
pub const QkDelayUnit_QkDelayUnit_NS: QkDelayUnit = 3;
#[doc = " Picoseconds."]
pub const QkDelayUnit_QkDelayUnit_PS: QkDelayUnit = 4;
pub type QkDelayUnit = u8;
pub const QkGate_QkGate_GlobalPhase: QkGate = 0;
pub const QkGate_QkGate_H: QkGate = 1;
pub const QkGate_QkGate_I: QkGate = 2;
pub const QkGate_QkGate_X: QkGate = 3;
pub const QkGate_QkGate_Y: QkGate = 4;
pub const QkGate_QkGate_Z: QkGate = 5;
pub const QkGate_QkGate_Phase: QkGate = 6;
pub const QkGate_QkGate_R: QkGate = 7;
pub const QkGate_QkGate_RX: QkGate = 8;
pub const QkGate_QkGate_RY: QkGate = 9;
pub const QkGate_QkGate_RZ: QkGate = 10;
pub const QkGate_QkGate_S: QkGate = 11;
pub const QkGate_QkGate_Sdg: QkGate = 12;
pub const QkGate_QkGate_SX: QkGate = 13;
pub const QkGate_QkGate_SXdg: QkGate = 14;
pub const QkGate_QkGate_T: QkGate = 15;
pub const QkGate_QkGate_Tdg: QkGate = 16;
pub const QkGate_QkGate_U: QkGate = 17;
pub const QkGate_QkGate_U1: QkGate = 18;
pub const QkGate_QkGate_U2: QkGate = 19;
pub const QkGate_QkGate_U3: QkGate = 20;
pub const QkGate_QkGate_CH: QkGate = 21;
pub const QkGate_QkGate_CX: QkGate = 22;
pub const QkGate_QkGate_CY: QkGate = 23;
pub const QkGate_QkGate_CZ: QkGate = 24;
pub const QkGate_QkGate_DCX: QkGate = 25;
pub const QkGate_QkGate_ECR: QkGate = 26;
pub const QkGate_QkGate_Swap: QkGate = 27;
pub const QkGate_QkGate_ISwap: QkGate = 28;
pub const QkGate_QkGate_CPhase: QkGate = 29;
pub const QkGate_QkGate_CRX: QkGate = 30;
pub const QkGate_QkGate_CRY: QkGate = 31;
pub const QkGate_QkGate_CRZ: QkGate = 32;
pub const QkGate_QkGate_CS: QkGate = 33;
pub const QkGate_QkGate_CSdg: QkGate = 34;
pub const QkGate_QkGate_CSX: QkGate = 35;
pub const QkGate_QkGate_CU: QkGate = 36;
pub const QkGate_QkGate_CU1: QkGate = 37;
pub const QkGate_QkGate_CU3: QkGate = 38;
pub const QkGate_QkGate_RXX: QkGate = 39;
pub const QkGate_QkGate_RYY: QkGate = 40;
pub const QkGate_QkGate_RZZ: QkGate = 41;
pub const QkGate_QkGate_RZX: QkGate = 42;
pub const QkGate_QkGate_XXMinusYY: QkGate = 43;
pub const QkGate_QkGate_XXPlusYY: QkGate = 44;
pub const QkGate_QkGate_CCX: QkGate = 45;
pub const QkGate_QkGate_CCZ: QkGate = 46;
pub const QkGate_QkGate_CSwap: QkGate = 47;
pub const QkGate_QkGate_RCCX: QkGate = 48;
pub const QkGate_QkGate_C3X: QkGate = 49;
pub const QkGate_QkGate_C3SX: QkGate = 50;
pub const QkGate_QkGate_RC3X: QkGate = 51;
pub type QkGate = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkCircuit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkObs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkTarget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkTargetEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkTranspileLayout {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkVF2LayoutResult {
    _unused: [u8; 0],
}
#[doc = " An individual operation count represented by the operation name\n and the number of instances in the circuit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkOpCount {
    #[doc = " A nul terminated string representing the operation name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The number of instances of this operation in the circuit"]
    pub count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkOpCount"][::std::mem::size_of::<QkOpCount>() - 16usize];
    ["Alignment of QkOpCount"][::std::mem::align_of::<QkOpCount>() - 8usize];
    ["Offset of field: QkOpCount::name"][::std::mem::offset_of!(QkOpCount, name) - 0usize];
    ["Offset of field: QkOpCount::count"][::std::mem::offset_of!(QkOpCount, count) - 8usize];
};
#[doc = " An array of ``OpCount`` objects representing the total counts of all\n the operation types in a circuit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkOpCounts {
    #[doc = " A array of size ``len`` containing ``OpCount`` objects for each\n type of operation in the circuit"]
    pub data: *mut QkOpCount,
    #[doc = " The number of elements in ``data``"]
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkOpCounts"][::std::mem::size_of::<QkOpCounts>() - 16usize];
    ["Alignment of QkOpCounts"][::std::mem::align_of::<QkOpCounts>() - 8usize];
    ["Offset of field: QkOpCounts::data"][::std::mem::offset_of!(QkOpCounts, data) - 0usize];
    ["Offset of field: QkOpCounts::len"][::std::mem::offset_of!(QkOpCounts, len) - 8usize];
};
#[doc = " A circuit instruction representation.\n\n This struct represents the data contained in an individual instruction in a ``QkCircuit``.\n It is not a pointer to the underlying object, but contains a copy of the properties of the\n instruction for inspection."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkCircuitInstruction {
    #[doc = " The instruction name"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " A pointer to an array of qubit indices this instruction operates on."]
    pub qubits: *mut u32,
    #[doc = " A pointer to an array of clbit indices this instruction operates on."]
    pub clbits: *mut u32,
    #[doc = " A pointer to an array of parameter values for this instruction."]
    pub params: *mut f64,
    #[doc = " The number of qubits for this instruction."]
    pub num_qubits: u32,
    #[doc = " The number of clbits for this instruction."]
    pub num_clbits: u32,
    #[doc = " The number of parameters for this instruction."]
    pub num_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkCircuitInstruction"][::std::mem::size_of::<QkCircuitInstruction>() - 48usize];
    ["Alignment of QkCircuitInstruction"][::std::mem::align_of::<QkCircuitInstruction>() - 8usize];
    ["Offset of field: QkCircuitInstruction::name"]
        [::std::mem::offset_of!(QkCircuitInstruction, name) - 0usize];
    ["Offset of field: QkCircuitInstruction::qubits"]
        [::std::mem::offset_of!(QkCircuitInstruction, qubits) - 8usize];
    ["Offset of field: QkCircuitInstruction::clbits"]
        [::std::mem::offset_of!(QkCircuitInstruction, clbits) - 16usize];
    ["Offset of field: QkCircuitInstruction::params"]
        [::std::mem::offset_of!(QkCircuitInstruction, params) - 24usize];
    ["Offset of field: QkCircuitInstruction::num_qubits"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_qubits) - 32usize];
    ["Offset of field: QkCircuitInstruction::num_clbits"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_clbits) - 36usize];
    ["Offset of field: QkCircuitInstruction::num_params"]
        [::std::mem::offset_of!(QkCircuitInstruction, num_params) - 40usize];
};
#[doc = " A term in a ``QkObs``.\n\n This contains the coefficient (``coeff``), the number of qubits of the observable\n (``num_qubits``) and pointers to the ``bit_terms`` and ``indices`` arrays, which have\n length ``len``. It's the responsibility of the user that the data is coherent,\n see also the below section on safety.\n\n # Safety\n\n * ``bit_terms`` must be a non-null, aligned pointer to ``len`` elements of type ``QkBitTerm``.\n * ``indices`` must be a non-null, aligned pointer to ``len`` elements of type ``uint32_t``."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkObsTerm {
    #[doc = " The coefficient of the observable term."]
    pub coeff: QkComplex64,
    #[doc = " Length of the ``bit_terms`` and ``indices`` arrays."]
    pub len: usize,
    #[doc = " A non-null, aligned pointer to ``len`` elements of type ``QkBitTerm``."]
    pub bit_terms: *mut QkBitTerm,
    #[doc = " A non-null, aligned pointer to ``len`` elements of type ``uint32_t``."]
    pub indices: *mut u32,
    #[doc = " The number of qubits the observable term is defined on."]
    pub num_qubits: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkObsTerm"][::std::mem::size_of::<QkObsTerm>() - 48usize];
    ["Alignment of QkObsTerm"][::std::mem::align_of::<QkObsTerm>() - 8usize];
    ["Offset of field: QkObsTerm::coeff"][::std::mem::offset_of!(QkObsTerm, coeff) - 0usize];
    ["Offset of field: QkObsTerm::len"][::std::mem::offset_of!(QkObsTerm, len) - 16usize];
    ["Offset of field: QkObsTerm::bit_terms"]
        [::std::mem::offset_of!(QkObsTerm, bit_terms) - 24usize];
    ["Offset of field: QkObsTerm::indices"][::std::mem::offset_of!(QkObsTerm, indices) - 32usize];
    ["Offset of field: QkObsTerm::num_qubits"]
        [::std::mem::offset_of!(QkObsTerm, num_qubits) - 40usize];
};
#[doc = " The options for running ``qk_transpiler_pass_standalone_sabre_layout``. This struct is used\n as an input to control the behavior of the layout and routing algorithms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkSabreLayoutOptions {
    #[doc = " The number of forward-backward iterations in the sabre routing algorithm"]
    pub max_iterations: usize,
    #[doc = " The number of trials to run of the sabre routing algorithm for each iteration. When > 1 the\n trial that routing trial that results in the output with the fewest swap gates will be\n selected."]
    pub num_swap_trials: usize,
    #[doc = " The number of random layout trials to run. The trial that results in the output with the\n fewest swap gates will be selected."]
    pub num_random_trials: usize,
    #[doc = " A seed value for the pRNG used internally."]
    pub seed: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkSabreLayoutOptions"][::std::mem::size_of::<QkSabreLayoutOptions>() - 32usize];
    ["Alignment of QkSabreLayoutOptions"][::std::mem::align_of::<QkSabreLayoutOptions>() - 8usize];
    ["Offset of field: QkSabreLayoutOptions::max_iterations"]
        [::std::mem::offset_of!(QkSabreLayoutOptions, max_iterations) - 0usize];
    ["Offset of field: QkSabreLayoutOptions::num_swap_trials"]
        [::std::mem::offset_of!(QkSabreLayoutOptions, num_swap_trials) - 8usize];
    ["Offset of field: QkSabreLayoutOptions::num_random_trials"]
        [::std::mem::offset_of!(QkSabreLayoutOptions, num_random_trials) - 16usize];
    ["Offset of field: QkSabreLayoutOptions::seed"]
        [::std::mem::offset_of!(QkSabreLayoutOptions, seed) - 24usize];
};
#[doc = " The options for running the transpiler"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkTranspileOptions {
    #[doc = " The optimization level to run the transpiler with. Valid values are 0, 1, 2, or 3."]
    pub optimization_level: u8,
    #[doc = " The seed for the transpiler. If set to a negative number this means no seed will be\n set and the RNGs used in the transpiler will be seeded from system entropy."]
    pub seed: i64,
    #[doc = " The approximation degree a heurstic dial where 1.0 means no approximation (up to numerical\n tolerance) and 0.0 means the maximum approximation. A `NAN` value indicates that\n approximation is allowed up to the reported error rate for an operation in the target."]
    pub approximation_degree: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkTranspileOptions"][::std::mem::size_of::<QkTranspileOptions>() - 24usize];
    ["Alignment of QkTranspileOptions"][::std::mem::align_of::<QkTranspileOptions>() - 8usize];
    ["Offset of field: QkTranspileOptions::optimization_level"]
        [::std::mem::offset_of!(QkTranspileOptions, optimization_level) - 0usize];
    ["Offset of field: QkTranspileOptions::seed"]
        [::std::mem::offset_of!(QkTranspileOptions, seed) - 8usize];
    ["Offset of field: QkTranspileOptions::approximation_degree"]
        [::std::mem::offset_of!(QkTranspileOptions, approximation_degree) - 16usize];
};
#[doc = " The container result object from ``qk_transpile``\n\n When the transpiler successfully compiles a quantum circuit for a given target it\n returns the transpiled circuit and the layout. The ``qk_transpile`` function will\n write pointers to the fields in this struct when it successfully executes, you can\n initialize this struct with null pointers or leave them unset as the values are never\n read by ``qk_transpile`` and only written to. After calling ``qk_transpile`` you are\n responsible for calling ``qk_circuit_free`` and ``qk_transpile_layout_free`` on the\n members of this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QkTranspileResult {
    pub circuit: *mut QkCircuit,
    pub layout: *mut QkTranspileLayout,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of QkTranspileResult"][::std::mem::size_of::<QkTranspileResult>() - 16usize];
    ["Alignment of QkTranspileResult"][::std::mem::align_of::<QkTranspileResult>() - 8usize];
    ["Offset of field: QkTranspileResult::circuit"]
        [::std::mem::offset_of!(QkTranspileResult, circuit) - 0usize];
    ["Offset of field: QkTranspileResult::layout"]
        [::std::mem::offset_of!(QkTranspileResult, layout) - 8usize];
};
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Construct a new circuit with the given number of qubits and clbits.\n\n @param num_qubits The number of qubits the circuit contains.\n @param num_clbits The number of clbits the circuit contains.\n\n @return A pointer to the created circuit.\n\n # Example\n\n     QkCircuit *empty = qk_circuit_new(100, 100);\n"]
    pub fn qk_circuit_new(num_qubits: u32, num_clbits: u32) -> *mut QkCircuit;
}
unsafe extern "C" {
    #[doc = " @ingroup QkQuantumRegister\n Construct a new owning quantum register with a given number of qubits and name\n\n @param num_qubits The number of qubits to create the register for\n @param name The name string for the created register. The name must be comprised of\n valid UTF-8 characters.\n\n @return A pointer to the created register\n\n # Example\n ```c\n     QkQuantumRegister *qr = qk_quantum_register_new(5, \"five_qubits\");\n ```\n\n # Safety\n\n The `name` parameter must be a pointer to memory that contains a valid\n nul terminator at the end of the string. It also must be valid for reads of\n bytes up to and including the nul terminator."]
    pub fn qk_quantum_register_new(
        num_qubits: u32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut QkQuantumRegister;
}
unsafe extern "C" {
    #[doc = " @ingroup QkQuantumRegister\n Free a quantum register.\n\n @param reg A pointer to the register to free.\n\n # Example\n ```c\n     QkQuantumRegister *qr = qk_quantum_register_new(1024, \"qreg\");\n     qk_quantum_register_free(qr);\n ```\n\n # Safety\n\n Behavior is undefined if ``reg`` is not either null or a valid pointer to a\n ``QkQuantumRegister``."]
    pub fn qk_quantum_register_free(reg: *mut QkQuantumRegister);
}
unsafe extern "C" {
    #[doc = " @ingroup QkClassicalRegister\n Free a classical register.\n\n @param reg A pointer to the register to free.\n\n # Example\n ```c\n     QkClassicalRegister *cr = qk_classical_register_new(1024, \"creg\");\n     qk_classical_register_free(cr);\n ```\n\n # Safety\n\n Behavior is undefined if ``reg`` is not either null or a valid pointer to a\n ``QkClassicalRegister``."]
    pub fn qk_classical_register_free(reg: *mut QkClassicalRegister);
}
unsafe extern "C" {
    #[doc = " @ingroup QkClassicalRegister\n Construct a new owning classical register with a given number of clbits and name\n\n @param num_clbits The number of clbits to create the register for\n @param name The name string for the created register. The name must be comprised of\n valid UTF-8 characters.\n\n @return A pointer to the created register\n\n # Example\n ```c\n     QkClassicalRegister *cr = qk_classical_register_new(5, \"five_qubits\");\n ```\n\n # Safety\n\n The `name` parameter must be a pointer to memory that contains a valid\n nul terminator at the end of the string. It also must be valid for reads of\n bytes up to and including the nul terminator."]
    pub fn qk_classical_register_new(
        num_clbits: u32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut QkClassicalRegister;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Add a quantum register to a given quantum circuit\n\n @param circuit A pointer to the circuit.\n @param reg A pointer to the quantum register\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(0, 0);\n     QkQuantumRegister *qr = qk_quantum_register_new(1024, \"my_little_register\");\n     qk_circuit_add_quantum_register(qc, qr);\n     qk_quantum_register_free(qr);\n     qk_circuit_free(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit`` and\n if ``reg`` is not a valid, non-null pointer to a ``QkQuantumRegister``."]
    pub fn qk_circuit_add_quantum_register(circuit: *mut QkCircuit, reg: *const QkQuantumRegister);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Add a classical register to a given quantum circuit\n\n @param circuit A pointer to the circuit.\n @param reg A pointer to the classical register\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(0, 0);\n     QkClassicalRegister *cr = qk_classical_register_new(24, \"my_big_register\");\n     qk_circuit_add_classical_register(qc, cr);\n     qk_classical_register_free(cr);\n     qk_circuit_free(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit`` and\n if ``reg`` is not a valid, non-null pointer to a ``QkClassicalRegister``."]
    pub fn qk_circuit_add_classical_register(
        circuit: *mut QkCircuit,
        reg: *const QkClassicalRegister,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Create a copy of a ``QkCircuit``.\n\n @param circuit A pointer to the circuit to copy.\n\n @return A new pointer to a copy of the input ``circuit``.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 100);\n     QkCircuit *copy = qk_circuit_copy(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_copy(circuit: *const QkCircuit) -> *mut QkCircuit;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of qubits the circuit contains.\n\n @param circuit A pointer to the circuit.\n\n @return The number of qubits the circuit is defined on.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 100);\n     uint32_t num_qubits = qk_circuit_num_qubits(qc);  // num_qubits==100\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_qubits(circuit: *const QkCircuit) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of clbits the circuit contains.\n\n @param circuit A pointer to the circuit.\n\n @return The number of qubits the circuit is defined on.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 50);\n     uint32_t num_clbits = qk_circuit_num_clbits(qc);  // num_clbits==50\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_clbits(circuit: *const QkCircuit) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Free the circuit.\n\n @param circuit A pointer to the circuit to free.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 100);\n     qk_circuit_free(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not either null or a valid pointer to a\n ``QkCircuit``."]
    pub fn qk_circuit_free(circuit: *mut QkCircuit);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a ``QkGate`` to the circuit.\n\n @param circuit A pointer to the circuit to add the gate to.\n @param gate The StandardGate to add to the circuit.\n @param qubits The pointer to the array of ``uint32_t`` qubit indices to add the gate on. This\n     can be a null pointer if there are no qubits for ``gate`` (e.g. ``QkGate_GlobalPhase``).\n @param params The pointer to the array of ``double`` values to use for the gate parameters.\n     This can be a null pointer if there are no parameters for ``gate`` (e.g. ``QkGate_H``).\n\n @return An exit code.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 0);\n     uint32_t qubit[1] = {0};\n     qk_circuit_gate(qc, QkGate_H, qubit, NULL);\n ```\n\n # Safety\n\n The ``qubits`` and ``params`` types are expected to be a pointer to an array of ``uint32_t``\n and ``double`` respectively where the length is matching the expectations for the standard\n gate. If the array is insufficiently long the behavior of this function is undefined as this\n will read outside the bounds of the array. It can be a null pointer if there are no qubits\n or params for a given gate. You can check ``qk_gate_num_qubits`` and ``qk_gate_num_params`` to\n determine how many qubits and params are required for a given gate.\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_gate(
        circuit: *mut QkCircuit,
        gate: QkGate,
        qubits: *const u32,
        params: *const f64,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of qubits for a ``QkGate``.\n\n @param gate The ``QkGate`` to get the number of qubits for.\n\n @return The number of qubits the gate acts on.\n\n # Example\n ```c\n     uint32_t num_qubits = qk_gate_num_qubits(QkGate_CCX);\n ```\n"]
    pub fn qk_gate_num_qubits(gate: QkGate) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Get the number of parameters for a ``QkGate``.\n\n @param gate The ``QkGate`` to get the number of qubits for.\n\n @return The number of parameters the gate has.\n\n # Example\n ```c\n     uint32_t num_params = qk_gate_num_params(QkGate_R);\n ```\n"]
    pub fn qk_gate_num_params(gate: QkGate) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a measurement to the circuit\n\n @param circuit A pointer to the circuit to add the measurement to\n @param qubit The ``uint32_t`` for the qubit to measure\n @param clbit The ``uint32_t`` for the clbit to store the measurement outcome in\n\n @return An exit code.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 1);\n     qk_circuit_measure(qc, 0, 0);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_measure(circuit: *mut QkCircuit, qubit: u32, clbit: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a reset to the circuit\n\n @param circuit A pointer to the circuit to add the reset to\n @param qubit The ``uint32_t`` for the qubit to reset\n\n @return An exit code.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 0);\n     qk_circuit_reset(qc, 0);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_reset(circuit: *mut QkCircuit, qubit: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a barrier to the circuit.\n\n @param circuit A pointer to the circuit to add the barrier to.\n @param num_qubits The number of qubits wide the barrier is.\n @param qubits The pointer to the array of ``uint32_t`` qubit indices to add the barrier on.\n\n @return An exit code.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 1);\n     uint32_t qubits[5] = {0, 1, 2, 3, 4};\n     qk_circuit_barrier(qc, qubits, 5);\n ```\n\n # Safety\n\n The length of the array ``qubits`` points to must be ``num_qubits``. If there is\n a mismatch the behavior is undefined.\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_barrier(
        circuit: *mut QkCircuit,
        qubits: *const u32,
        num_qubits: u32,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append an arbitrary unitary matrix to the circuit.\n\n @param circuit A pointer to the circuit to append the unitary to.\n @param matrix A pointer to the ``QkComplex64`` array representing the unitary matrix.\n     This must be a row-major, unitary matrix of dimension ``2 ^ num_qubits x 2 ^ num_qubits``.\n     More explicitly: the ``(i, j)``-th element is given by ``matrix[i * 2^n + j]``.\n     The contents of ``matrix`` are copied inside this function before being added to the circuit,\n     so caller keeps ownership of the original memory that ``matrix`` points to and can reuse it\n     after the call and the caller is responsible for freeing it.\n @param qubits A pointer to array of qubit indices, of length ``num_qubits``.\n @param num_qubits The number of qubits the unitary acts on.\n @param check_input When true, the function verifies that the matrix is unitary.\n     If set to False the caller is responsible for ensuring the matrix is unitary, if\n     the matrix is not unitary this is undefined behavior and will result in a corrupt\n     circuit.\n # Example\n ```c\n   QkComplex64 c0 = {0, 0};  // 0+0i\n   QkComplex64 c1 = {1, 0};  // 1+0i\n\n   const uint32_t num_qubits = 1;\n   QkComplex64 unitary[2*2] = {c0, c1,  // row 0\n                                     c1, c0}; // row 1\n\n   QkCircuit *circuit = qk_circuit_new(1, 0);  // 1 qubit circuit\n   uint32_t qubit[1] = {0};  // qubit to apply the unitary on\n   qk_circuit_unitary(circuit, unitary, qubit, num_qubits, true);\n ```\n\n # Safety\n\n Behavior is undefined if any of the following is violated:\n\n   * ``circuit`` is a valid, non-null pointer to a ``QkCircuit``\n   * ``matrix`` is a pointer to a nested array of ``QkComplex64`` of dimension\n     ``2 ^ num_qubits x 2 ^ num_qubits``\n   * ``qubits`` is a pointer to ``num_qubits`` readable element of type ``uint32_t``\n"]
    pub fn qk_circuit_unitary(
        circuit: *mut QkCircuit,
        matrix: *const QkComplex64,
        qubits: *const u32,
        num_qubits: u32,
        check_input: bool,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return a list of string names for instructions in a circuit and their counts.\n\n To properly free the memory allocated by the struct, you should call ``qk_opcounts_clear``.\n Dropping the ``QkOpCounts`` struct without doing so will leave the stored array of ``QkOpCount``\n allocated and produce a memory leak.\n\n @param circuit A pointer to the circuit to get the counts for.\n\n @return An ``QkOpCounts`` struct containing the circuit operation counts.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 0);\n     uint32_t qubits[1] = {0};\n     qk_circuit_gate(qc, QkGate_H, qubits, NULL);\n     QkOpCounts counts = qk_circuit_count_ops(qc);\n     // .. once done\n     qk_opcounts_clear(&counts);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_count_ops(circuit: *const QkCircuit) -> QkOpCounts;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return the total number of instructions in the circuit.\n\n @param circuit A pointer to the circuit to get the total number of instructions for.\n\n @return The total number of instructions in the circuit.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(100, 0);\n     uint32_t qubit[1] = {0};\n     qk_circuit_gate(qc, QkGate_H, qubit, NULL);\n     size_t num = qk_circuit_num_instructions(qc); // 1\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_num_instructions(circuit: *const QkCircuit) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Return the instruction details for an instruction in the circuit.\n\n This function is used to get the instruction details for a given instruction in\n the circuit.\n\n This function allocates memory internally for the provided ``QkCircuitInstruction``\n and thus you are responsible for calling ``qk_circuit_instruction_clear`` to\n free it.\n\n @param circuit A pointer to the circuit to get the instruction details for.\n @param index The instruction index to get the instruction details of.\n @param instruction A pointer to where to write out the ``QkCircuitInstruction``\n\n\n # Example\n ```c\n     QkCircuitInstruction inst;\n     QkCircuit *qc = qk_circuit_new(100, 0);\n     uint32_t qubit[1] = {0};\n     qk_circuit_gate(qc, QkGate_H, qubit, NULL);\n     qk_circuit_get_instruction(qc, 0, &inst);\n     qk_circuit_instruction_clear(&inst);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``. The\n value for ``index`` must be less than the value returned by ``qk_circuit_num_instructions``\n otherwise this function will panic. Behavior is undefined if ``instruction`` is not a valid,\n non-null pointer to a memory allocation with sufficient space for a ``QkCircuitInstruction``."]
    pub fn qk_circuit_get_instruction(
        circuit: *const QkCircuit,
        index: usize,
        instruction: *mut QkCircuitInstruction,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Clear the data in circuit instruction object.\n\n This function doesn't free the allocation for the provided ``QkCircuitInstruction`` pointer, it\n only frees the internal allocations for the data contained in the instruction. You are\n responsible for allocating and freeing the actual allocation used to store a\n ``QkCircuitInstruction``.\n\n @param inst A pointer to the instruction to free.\n\n # Example\n ```c\n     QkCircuitInstruction *inst = malloc(sizeof(QkCircuitInstruction));\n     QkCircuit *qc = qk_circuit_new(100, 0);\n     uint32_t q0[1] = {0};\n     qk_circuit_gate(qc, QkGate_H, q0, NULL);\n     qk_circuit_get_instruction(qc, 0, inst);\n     qk_circuit_instruction_clear(inst); // clear internal allocations\n     free(inst); // free struct\n     qk_circuit_free(qc); // free the circuit\n ```\n\n # Safety\n\n Behavior is undefined if ``inst`` is not a valid, non-null pointer to a ``QkCircuitInstruction``."]
    pub fn qk_circuit_instruction_clear(inst: *mut QkCircuitInstruction);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Clear the content in a circuit operation count list.\n\n @param op_counts The returned op count list from ``qk_circuit_count_ops``.\n\n # Safety\n\n Behavior is undefined if ``op_counts`` is not the object returned by ``qk_circuit_count_ops``."]
    pub fn qk_opcounts_clear(op_counts: *mut QkOpCounts);
}
unsafe extern "C" {
    #[doc = " @ingroup QkCircuit\n Append a delay instruction to the circuit.\n\n @param circuit A pointer to the circuit to add the delay to.\n @param qubit The ``uint32_t`` index of the qubit to apply the delay to.\n @param duration The duration of the delay.\n @param unit An enum representing the unit of the duration.\n\n @return An exit code.\n\n # Example\n ```c\n     QkCircuit *qc = qk_circuit_new(1, 0);\n     qk_circuit_delay(qc, 0, 100.0, QkDelayUnit_NS);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_circuit_delay(
        circuit: *mut QkCircuit,
        qubit: u32,
        duration: f64,
        unit: QkDelayUnit,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct the zero observable (without any terms).\n\n @param num_qubits The number of qubits the observable is defined on.\n\n @return A pointer to the created observable.\n\n # Example\n ```c\n     QkObs *zero = qk_obs_zero(100);\n ```\n"]
    pub fn qk_obs_zero(num_qubits: u32) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct the identity observable.\n\n @param num_qubits The number of qubits the observable is defined on.\n\n @return A pointer to the created observable.\n\n # Example\n ```c\n     QkObs *identity = qk_obs_identity(100);\n ```\n"]
    pub fn qk_obs_identity(num_qubits: u32) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Construct a new observable from raw data.\n\n @param num_qubits The number of qubits the observable is defined on.\n @param num_terms The number of terms.\n @param num_bits The total number of non-identity bit terms.\n @param coeffs A pointer to the first element of the coefficients array, which has length\n     ``num_terms``.\n @param bit_terms A pointer to the first element of the bit terms array, which has length\n     ``num_bits``.\n @param indices A pointer to the first element of the indices array, which has length\n     ``num_bits``. Note that, per term, these *must* be sorted incrementally.\n @param boundaries A pointer to the first element of the boundaries array, which has length\n     ``num_terms + 1``.\n\n @return If the input data was coherent and the construction successful, the result is a pointer\n     to the observable. Otherwise a null pointer is returned.\n\n # Example\n ```c\n    // define the raw data for the 100-qubit observable |01><01|_{0, 1} - |+-><+-|_{98, 99}\n    uint32_t num_qubits = 100;\n    uint64_t num_terms = 2;  // we have 2 terms: |01><01|, -1 * |+-><+-|\n    uint64_t num_bits = 4; // we have 4 non-identity bits: 0, 1, +, -\n    QkComplex64 coeffs = {1, -1};\n    QkBitTerm bits[4] = {QkBitTerm_Zero, QkBitTerm_One, QkBitTerm_Plus, QkBitTerm_Minus};\n\n    uint32_t indices[4] = {0, 1, 98, 99};  // <-- e.g. {1, 0, 99, 98} would be invalid\n    size_t boundaries[3] = {0, 2, 4};\n    QkObs *obs = qk_obs_new(\n        num_qubits, num_terms, num_bits, &coeffs, bits, indices, boundaries\n    );\n ```\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n   * ``coeffs`` is a pointer to a ``QkComplex64`` array of length ``num_terms``\n   * ``bit_terms`` is a pointer to an array of valid ``QkBitTerm`` elements of length ``num_bits``\n   * ``indices`` is a pointer to a ``uint32_t`` array of length ``num_bits``, which is\n     term-wise sorted in strict ascending order, and every element is smaller than ``num_qubits``\n   * ``boundaries`` is a pointer to a ``size_t`` array of length ``num_terms + 1``, which is\n     sorted in ascending order, the first element is 0 and the last element is\n     smaller than ``num_terms``"]
    pub fn qk_obs_new(
        num_qubits: u32,
        num_terms: u64,
        num_bits: u64,
        coeffs: *mut QkComplex64,
        bit_terms: *mut QkBitTerm,
        indices: *mut u32,
        boundaries: *mut usize,
    ) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Free the observable.\n\n @param obs A pointer to the observable to free.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_zero(100);\n     qk_obs_free(obs);\n ```\n\n # Safety\n\n Behavior is undefined if ``obs`` is not either null or a valid pointer to a ``QkObs``."]
    pub fn qk_obs_free(obs: *mut QkObs);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Add a term to the observable.\n\n @param obs A pointer to the observable.\n @param cterm A pointer to the term to add.\n\n @return An exit code. This is ``>0`` if the term is incoherent or adding the term fails.\n\n # Example\n ```c\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     QkComplex64 coeff = {1, 0};\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {coeff, 3, bit_terms, indices, num_qubits};\n\n     int exit_code = qk_obs_add_term(obs, &term);\n ```\n\n # Safety\n\n Behavior is undefined if any of the following is violated:\n\n   * ``obs`` is a valid, non-null pointer to a ``QkObs``\n   * ``cterm`` is a valid, non-null pointer to a ``QkObsTerm``"]
    pub fn qk_obs_add_term(obs: *mut QkObs, cterm: *const QkObsTerm) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get an observable term by reference.\n\n A ``QkObsTerm`` contains pointers to the indices and bit terms in the term, which\n can be used to modify the internal data of the observable. This can leave the observable\n in an incoherent state and should be avoided, unless great care is taken. It is generally\n safer to construct a new observable instead of attempting in-place modifications.\n\n @param obs A pointer to the observable.\n @param index The index of the term to get.\n @param out A pointer to a ``QkObsTerm`` used to return the observable term.\n\n @return An exit code.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     QkObsTerm term;\n     int exit_code = qk_obs_term(obs, 0, &term);\n     // out-of-bounds indices return an error code\n     // int error = qk_obs_term(obs, 12, &term);\n ```\n\n # Safety\n\n Behavior is undefined if any of the following is violated\n * ``obs`` is a valid, non-null pointer to a ``QkObs``\n * ``out`` is a valid, non-null pointer to a ``QkObsTerm``"]
    pub fn qk_obs_term(obs: *mut QkObs, index: u64, out: *mut QkObsTerm) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of terms in the observable.\n\n @param obs A pointer to the observable.\n\n @return The number of terms in the observable.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     size_t num_terms = qk_obs_num_terms(obs);  // num_terms==1\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_num_terms(obs: *const QkObs) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of qubits the observable is defined on.\n\n @param obs A pointer to the observable.\n\n @return The number of qubits the observable is defined on.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     uint32_t num_qubits = qk_obs_num_qubits(obs);  // num_qubits==100\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_num_qubits(obs: *const QkObs) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get the number of bit terms/indices in the observable.\n\n @param obs A pointer to the observable.\n\n @return The number of terms in the observable.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     size_t len = qk_obs_len(obs);  // len==0, as there are no non-trivial bit terms\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_len(obs: *const QkObs) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the coefficients.\n\n This can be used to read and modify the observable's coefficients. The resulting\n pointer is valid to read for ``qk_obs_num_terms(obs)`` elements of ``QkComplex64``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the coefficients.\n\n # Example\n ```c\n    QkObs *obs = qk_obs_identity(100);\n    size_t num_terms = qk_obs_num_terms(obs);\n    QkComplex64 *coeffs = qk_obs_coeffs(obs);\n\n    for (size_t i = 0; i < num_terms; i++) {\n        printf(\"%f + i%f\\n\", coeffs[i].re, coeffs[i].im);\n    }\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_coeffs(obs: *mut QkObs) -> *mut QkComplex64;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the indices.\n\n This can be used to read and modify the observable's indices. The resulting pointer is\n valid to read for ``qk_obs_len(obs)`` elements of size ``uint32_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the indices.\n\n # Example\n ```c\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     QkComplex64 coeff = {1, 0};\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t term_indices[3] = {0, 1, 2};\n     QkObsTerm term = {coeff, 3, bit_terms, term_indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_t len = qk_obs_len(obs);\n     uint32_t *indices = qk_obs_indices(obs);\n\n     for (size_t i = 0; i < len; i++) {\n         printf(\"index %i: %i\\n\", i, indices[i]);\n     }\n ```\n\n     qk_obs_free(obs);\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_indices(obs: *mut QkObs) -> *mut u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the term boundaries.\n\n This can be used to read and modify the observable's term boundaries. The resulting pointer is\n valid to read for ``qk_obs_num_terms(obs) + 1`` elements of size ``size_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the boundaries.\n\n # Example\n ```c\n    uint32_t num_qubits = 100;\n    QkObs *obs = qk_obs_zero(num_qubits);\n\n    QkComplex64 coeff = {1, 0};\n    QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n    uint32_t indices[3] = {0, 1, 2};\n    QkObsTerm term = {coeff, 3, bit_terms, indices, num_qubits};\n    qk_obs_add_term(obs, &term);\n\n    size_t num_terms = qk_obs_num_terms(obs);\n    size_t *boundaries = qk_obs_boundaries(obs);\n\n    for (size_t i = 0; i < num_terms + 1; i++) {\n        printf(\"boundary %i: %i\\n\", i, boundaries[i]);\n    }\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_boundaries(obs: *mut QkObs) -> *mut usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Get a pointer to the bit terms.\n\n This can be used to read and modify the observable's bit terms. The resulting pointer is\n valid to read for ``qk_obs_len(obs)`` elements of size ``uint8_t``.\n\n @param obs A pointer to the observable.\n\n @return A pointer to the bit terms.\n\n # Example\n ```c\n     uint32_t num_qubits = 100;\n     QkObs *obs = qk_obs_zero(num_qubits);\n\n     QkComplex64 coeff = {1, 0};\n     QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n     uint32_t indices[3] = {0, 1, 2};\n     QkObsTerm term = {coeff, 3, bit_terms, indices, num_qubits};\n     qk_obs_add_term(obs, &term);\n\n     size_t len = qk_obs_len(obs);\n     QkBitTerm *bits = qk_obs_bit_terms(obs);\n\n     for (size_t i = 0; i < len; i++) {\n         printf(\"bit term %i: %i\\n\", i, bits[i]);\n     }\n\n     qk_obs_free(obs);\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``,\n or if invalid valus are written into the resulting ``QkBitTerm`` pointer."]
    pub fn qk_obs_bit_terms(obs: *mut QkObs) -> *mut QkBitTerm;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Multiply the observable by a complex coefficient.\n\n @param obs A pointer to the observable.\n @param coeff The coefficient to multiply the observable with.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     QkComplex64 coeff = {2, 0};\n     QkObs *result = qk_obs_multiply(obs, &coeff);\n ```\n\n # Safety\n\n Behavior is undefined if any of the following is violated\n * ``obs`` is a valid, non-null pointer to a ``QkObs``\n * ``coeff`` is a valid, non-null pointer to a ``QkComplex64``"]
    pub fn qk_obs_multiply(obs: *const QkObs, coeff: *const QkComplex64) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Add two observables.\n\n @param left A pointer to the left observable.\n @param right A pointer to the right observable.\n\n @return A pointer to the result ``left + right``.\n\n # Example\n ```c\n     QkObs *left = qk_obs_identity(100);\n     QkObs *right = qk_obs_zero(100);\n     QkObs *result = qk_obs_add(left, right);\n ```\n\n # Safety\n\n Behavior is undefined if ``left`` or ``right`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_add(left: *const QkObs, right: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compose (multiply) two observables.\n\n @param first One observable.\n @param second The other observable.\n\n @return ``first.compose(second)`` which equals the observable ``result = second @ first``,\n     in terms of the matrix multiplication ``@``.\n\n # Example\n ```c\n     QkObs *first = qk_obs_zero(100);\n     QkObs *second = qk_obs_identity(100);\n     QkObs *result = qk_obs_compose(first, second);\n ```\n\n # Safety\n\n Behavior is undefined if ``first`` or ``second`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_compose(first: *const QkObs, second: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compose (multiply) two observables according to a custom qubit order.\n\n Notably, this allows composing two observables of different size.\n\n @param first One observable.\n @param second The other observable. The number of qubits must match the length of ``qargs``.\n @param qargs The qubit arguments specified which indices in ``first`` to associate with\n     the ones in ``second``.\n\n @return ``first.compose(second)`` which equals the observable ``result = second @ first``,\n     in terms of the matrix multiplication ``@``.\n\n # Example\n ```c\n     QkObs *first = qk_obs_zero(100);\n     QkObs *second = qk_obs_identity(100);\n     QkObs *result = qk_obs_compose(first, second);\n ```\n\n # Safety\n\n To call this function safely\n\n   * ``first`` and ``second`` must be valid, non-null pointers to ``QkObs``\\ s\n   * ``qargs`` must point to an array of ``uint32_t``, readable for ``qk_obs_num_qubits(second)``\n     elements (meaning the number of qubits in ``second``)"]
    pub fn qk_obs_compose_map(
        first: *const QkObs,
        second: *const QkObs,
        qargs: *const u32,
    ) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Apply a new qubit layout to the observable.\n\n The layout is set by an array ``layout`` of new indices, specifying that qubit at current\n index ``i`` is relabelled to index ``layout[i]``. The number of qubits the observable\n acts on can be extended by setting a larger ``num_qubits`` than the current observable has.\n\n @param obs A pointer to the observable, this observable will be modified in place upon success.\n Check the exit code to ensure the layout was correctly applied.\n @param layout A pointer to the layout. The pointer must point to an array to\n ``qk_obs_num_qubits(obs)`` elements of type ``uint32_t``. Each element must have values\n in ``[0, num_qubits)``.\n @param num_qubits The number of output qubits.\n\n @return An exit code.\n * ``QkExitCode_Success`` upon success\n * ``QkExitCode_DuplicteIndexError`` if duplicate qubit indices were found\n * ``QkExitCode_MismatchedQubits`` if ``num_qubits`` is smaller than the number of qubits in\n   the observable\n * ``QkExitCode_IndexError`` for any other index errors, such as invalid values in ``layout``.\n\n # Example\n\n This interface allows to relabel and extend the qubit indices:\n\n ```c\n QkObs *obs = qk_obs_zero(4);\n\n // add a term to the observable\n QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};\n uint32_t qubits[3] = {1, 2, 3};\n complex double coeff = 1;\n QkObsTerm term = {coeff, 3, bit_terms, qubits, 4};\n qk_obs_add_term(obs, &term);\n\n uint32_t layout[3] = {0, 10, 9};  // qubit mapping is: 0->0, 1->10, 2->9\n uint32_t num_output_qubits = 11;\n int exit = qk_obs_apply_layout(obs, layout, num_output_qubits);\n ```\n\n In a compiler workflow, this function can conveniently be used to apply a\n ``QkTranspileLayout*`` obtained from a transpiler pass, called ``transpile_layout``\n in the following example:\n\n ```c\n // get the number of output qubits\n uint32_t num_output_qubits = qk_transpile_layout_num_output_qubits(transpile_layout);\n\n // get the layout including the ancillas (hence the ``false`` in the function call)\n uint32_t *layout = malloc(sizeof(uint32_t) * num_output_qubits);\n qk_transpile_layout_final_layout(transpile_layout, false, layout);\n\n // apply the layout\n int exit = qk_obs_apply_layout(obs, layout, num_output_qubits);\n\n // free the layout array\n free(layout);\n ```\n\n # Safety\n\n Behavior is undefined if ``obs`` is not a valid, non-null pointer to ``QkObs`` or if ``layout``\n is not a valid, non-null pointer to a sequence of ``qk_obs_num_qubits(obs)`` consecutive\n elements of ``uint32_t``."]
    pub fn qk_obs_apply_layout(obs: *mut QkObs, layout: *const u32, num_qubits: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Calculate the canonical representation of the observable.\n\n @param obs A pointer to the observable.\n @param tol The tolerance below which coefficients are considered to be zero.\n\n @return The canonical representation of the observable.\n\n # Example\n ```c\n    QkObs *iden = qk_obs_identity(100);\n    QkObs *two = qk_obs_add(iden, iden);\n\n    double tol = 1e-6;\n    QkObs *canonical = qk_obs_canonicalize(two, tol);\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_canonicalize(obs: *const QkObs, tol: f64) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Copy the observable.\n\n @param obs A pointer to the observable.\n\n @return A pointer to a copy of the observable.\n\n # Example\n ```c\n     QkObs *original = qk_obs_identity(100);\n     QkObs *copied = qk_obs_copy(original);\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``."]
    pub fn qk_obs_copy(obs: *const QkObs) -> *mut QkObs;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Compare two observables for equality.\n\n Note that this does not compare mathematical equality, but data equality. This means\n that two observables might represent the same observable but not compare as equal.\n\n @param obs A pointer to one observable.\n @param other A pointer to another observable.\n\n @return ``true`` if the observables are equal, ``false`` otherwise.\n\n # Example\n ```c\n     QkObs *observable = qk_obs_identity(100);\n     QkObs *other = qk_obs_identity(100);\n     bool are_equal = qk_obs_equal(observable, other);\n ```\n\n # Safety\n\n Behavior is undefined if ``obs`` or ``other`` are not valid, non-null pointers to\n ``QkObs``\\ s."]
    pub fn qk_obs_equal(obs: *const QkObs, other: *const QkObs) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Return a string representation of a ``QkObs``.\n\n @param obs A pointer to the ``QkObs`` to get the string for.\n\n @return A pointer to a nul-terminated char array of the string representation for ``obs``\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     char *string = qk_obs_str(obs);\n     qk_str_free(string);\n ```\n\n # Safety\n\n Behavior is undefined ``obs`` is not a valid, non-null pointer to a ``QkObs``.\n\n The string must not be freed with the normal C free, you must use ``qk_str_free`` to\n free the memory consumed by the String. Not calling ``qk_str_free`` will lead to a\n memory leak.\n\n Do not change the length of the string after it's returned (by writing a nul byte somewhere\n inside the string or removing the final one), although values can be mutated."]
    pub fn qk_obs_str(obs: *const QkObs) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @ingroup QkObs\n Free a string representation.\n\n @param string A pointer to the returned string representation from ``qk_obs_str`` or\n     ``qk_obsterm_str``.\n\n # Safety\n\n Behavior is undefined if ``str`` is not a pointer returned by ``qk_obs_str`` or\n ``qk_obsterm_str``."]
    pub fn qk_str_free(string: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @ingroup QkObsTerm\n Return a string representation of the sparse term.\n\n @param term A pointer to the term.\n\n @return The function exit code. This is ``>0`` if reading the term failed.\n\n # Example\n ```c\n     QkObs *obs = qk_obs_identity(100);\n     QkObsTerm term;\n     qk_obs_term(obs, 0, &term);\n     char *string = qk_obsterm_str(&term);\n     qk_str_free(string);\n ```\n\n # Safety\n\n Behavior is undefined ``term`` is not a valid, non-null pointer to a ``QkObsTerm``.\n\n The string must not be freed with the normal C free, you must use ``qk_str_free`` to\n free the memory consumed by the String. Not calling ``qk_str_free`` will lead to a\n memory leak.\n\n Do not change the length of the string after it's returned, although values can be mutated."]
    pub fn qk_obsterm_str(term: *const QkObsTerm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " @ingroup QkBitTerm\n Get the label for a bit term.\n\n @param bit_term The bit term.\n\n @return The label as ``uint8_t``, which can be cast to ``char`` to obtain the character.\n\n # Example\n ```c\n     QkBitTerm bit_term = QkBitTerm_Y;\n     // cast the uint8_t to char\n     char label = qk_bitterm_label(bit_term);\n ```\n\n # Safety\n\n The behavior is undefined if ``bit_term`` is not a valid ``uint8_t`` value of a ``QkBitTerm``."]
    pub fn qk_bitterm_label(bit_term: QkBitTerm) -> u8;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the BasisTranslator transpiler pass on a circuit.\n\n The BasisTranslator transpiler pass translates gates to a target basis by\n searching for a set of translations from the standard EquivalenceLibrary.\n\n @param circuit A pointer to the circuit to run BasisTranslator on.\n The circuit will be mutated in-place, unless the circuit is already\n in the target basis, in which case the circuit remains unchanged.\n @param target The target where we will obtain basis gates from.\n @param min_qubits The minimum number of qubits for operations in the input\n ciruit to translate.\n\n # Example\n\n ```c\n    #include <qiskit.h>\n\n    QkCircuit *circuit = qk_circuit_new(3, 0);\n    qk_circuit_gate(circuit, QkGate_CCX, (uint32_t[3]){0, 1, 2}, NULL);\n\n    // Create a Target with global properties.\n    QkTarget *target = qk_target_new(3);\n    qk_target_add_instruction(target, qk_target_entry_new(QkGate_H));\n    qk_target_add_instruction(target, qk_target_entry_new(QkGate_T));\n    qk_target_add_instruction(target, qk_target_entry_new(QkGate_Tdg));\n    qk_target_add_instruction(target, qk_target_entry_new(QkGate_CX));\n\n    // Run pass\n    qk_transpiler_pass_standalone_basis_translator(circuit, target, 0);\n\n    // Free the circuit and target pointers once you're done\n    qk_circuit_free(circuit);\n    qk_target_free(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` and/or ``target`` are not valid, non-null\n pointers to a ``QkCircuit`` or ``QkTarget``."]
    pub fn qk_transpiler_pass_standalone_basis_translator(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
        min_qubits: usize,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the CommutativeCancellation transpiler pass on a circuit.\n\n This pass cancels the redundant (self-adjoint) gates through commutation relations.\n\n @param circuit A pointer to the circuit to run CommutativeCancellation on. This circuit\n pointer to will be updated with the modified circuit if the pass is able to remove any gates.\n @param target This pass will attempt to accumulate all Z rotations into either\n an RZ, P or U1 gate, depending on which is already used in the circuit. If none\n is present in the circuit, this (optional) target argument is used as fallback to\n decide which gate to use. If none of RZ, P or U1 are in the circuit or the target,\n single-qubit Z rotations will not be optimized.\n @param approximation_degree The approximation degree used when\n analyzing commutations. Must be within ``(0, 1]``.\n @returns The integer return code where 0 represents no error and 1 is\n used to indicate an error was encountered during the execution of the pass.\n\n # Example\n\n ```c\n QkCircuit *qc = qk_circuit_new(4, 0);\n uint32_t cx_qargs[2] = {0, 1};\n qk_circuit_gate(qc, QkGate_CX, cx_qargs, NULL);\n qk_circuit_gate(qc, QkGate_Z, (uint32_t[]){0}, NULL);\n qk_circuit_gate(qc, QkGate_CX, cx_qargs, NULL);\n qk_transpiler_pass_standalone_commutative_cancellation(qc, NULL, 1.0);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` is not a valid, ``QkCircuit`` and ``QkTarget``.\n ``QkCircuit`` is not expected to be null and behavior is undefined if it is."]
    pub fn qk_transpiler_pass_standalone_commutative_cancellation(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
        approximation_degree: f64,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the ConsolidateBlocks pass on a circuit.\n\n ConsolidateBlocks is a transpiler pass that consolidates consecutive blocks of\n gates operating on the same qubits into a Unitary gate, to later on be\n resynthesized, which leads to a more optimal subcircuit.\n\n @param circuit A pointer to the circuit to run ConsolidateBlocks on.\n @param target A pointer to the target to run ConsolidateBlocks on.\n @param approximation_degree A float between `[0.0, 1.0]` or a `NaN` which\n defaults to `1.0`. Lower approximates more.\n @param force_consolidate: Force block consolidation.\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit`` and\n if ``target`` is not a valid pointer to a ``QkTarget``."]
    pub fn qk_transpiler_pass_standalone_consolidate_blocks(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
        approximation_degree: f64,
        force_consolidate: bool,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the ElidePermutations transpiler pass on a circuit.\n\n The ElidePermutations transpiler pass removes any permutation operations from a pre-layout\n circuit.\n\n This pass is intended to be run before a layout (mapping virtual qubits to physical qubits) is\n set during the transpilation pipeline. This pass iterates over the circuit\n and when a Swap gate is encountered it permutes the virtual qubits in\n the circuit and removes the swap gate. This will effectively remove any\n swap gates in the circuit prior to running layout. This optimization is\n not valid after a layout has been set and should not be run in this case.\n\n @param circuit A pointer to the circuit to run ElidePermutations on. If there are changes made\n     the object pointed to is changed in place. In case of gates being elided the original circuit's\n     allocations are freed by this function.\n\n @return the layout object containing the output permutation induced by the elided gates in the\n         circuit. If no elisions are performed this will be a null pointer and the input circuit\n         is unchanged.\n\n # Example\n\n ```c\n     QkCircuit *qc = qk_circuit_new(4, 0);\n     for (uint32_t i = 0; i < qk_circuit_num_qubits(qc) - 1; i++) {\n         uint32_t qargs[2] = {i, i + 1};\n         for (uint32_t j = 0; j<i+1; j++) {\n             qk_circuit_gate(qc, QkGate_CX, qargs, NULL);\n         }\n     }\n     QkTranspileLayout *elide_result = qk_transpiler_pass_standalone_elide_permutations(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit``  is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_transpiler_pass_standalone_elide_permutations(
        circuit: *mut QkCircuit,
    ) -> *mut QkTranspileLayout;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the ``CheckGateDirection`` pass on a circuit.\n\n The pass checks if the directions of two-qubit gates comply with the gate directions specified in a given target.\n\n @param circuit A pointer to the circuit on which to run the CheckGateDirection pass.\n @param target A pointer to the target used for checking gate directions.\n\n @return bool - true iff the directions of all two-qubit gates in the circuit comply with the specified target constraints.\n\n # Example\n ```c\n    QkTarget *target = qk_target_new(2);\n    uint32_t qargs[3] = {0,1};\n\n    QkTargetEntry *cx_entry = qk_target_entry_new(QkGate_CX);\n    qk_target_entry_add_property(cx_entry, qargs, 2, 0.0, 0.0);\n    qk_target_add_instruction(target, cx_entry);\n\n    QkCircuit *circuit = qk_circuit_new(2, 0);\n    qk_circuit_gate(circuit, QkGate_CX, (uint32_t[]){1,0}, NULL);\n\n    bool direction_ok = qk_transpiler_pass_standalone_check_gate_direction(circuit, target);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` are not valid, non-null pointers to ``QkCircuit`` and ``QkTarget`` objects, respectively."]
    pub fn qk_transpiler_pass_standalone_check_gate_direction(
        circuit: *const QkCircuit,
        target: *const QkTarget,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the ``GateDirection`` pass on a circuit.\n\n The GateDirection pass modifies asymmetric gates to match the hardware coupling directions.\n This pass supports replacements for the ``cx``, ``cz``, ``ecr``, ``swap``, ``rzx``, ``rxx``, ``ryy`` and\n ``rzz`` gates, using predefined identities.\n\n @param circuit A pointer to the circuit on which to run the GateDirection pass. The circuit will be modified\n     in place by the pass.\n @param target A pointer to the target used for checking gate directions.\n\n # Example\n ```c\n    QkTarget *target = qk_target_new(3);\n\n    uint32_t qargs[2] = {0,1};\n\n    QkTargetEntry *cx_entry = qk_target_entry_new(QkGate_CX);\n    qk_target_entry_add_property(cx_entry, qargs, 2, 0.0, 0.0);\n    qk_target_add_instruction(target, cx_entry);\n\n    QkCircuit *circuit = qk_circuit_new(3, 0);\n    qk_circuit_gate(circuit, QkGate_CX, (uint32_t[]){1,0}, NULL);\n\n    qk_transpiler_pass_standalone_gate_direction(circuit, target);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` are not valid, non-null pointers to ``QkCircuit`` and ``QkTarget`` objects, respectively."]
    pub fn qk_transpiler_pass_standalone_gate_direction(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the InverseCancellation transpiler pass on a circuit.\n\n Cancels pairs of consecutive gates that are inverses of each other.\n The cancelled gates consist of pairs of self-inverse gates:\n    - QkGate_H\n    - QkGate_X\n    - QkGate_Y\n    - QkGate_Z\n    - QkGate_CH\n    - QkGate_CX\n    - QkGate_CY\n    - QkGate_CZ\n    - QkGate_ECR\n    - QkGate_Swap\n    - QkGate_CCX\n    - QkGate_CCZ\n    - QkGate_CSwap\n    - QkGate_RCCX\n    - QkGate_C3X\n\n and pairs of inverse gates:\n    - (QkGate_T, QkGate_Tdg)\n    - (QkGate_S, QkGate_Sdg)\n    - (QkGate_SX, QkGate_SXdg)\n    - (QkGate_CS, QkGate_CSdg)\n\n @param circuit A pointer to the circuit to run InverseCancellation on. If the pass is able to\n remove any gates, the original circuit will be replaced by the circuit produced by this pass.\n\n # Example\n\n ```c\n     QkCircuit *qc = qk_circuit_new(2, 2);\n     uint32_t qargs[1] = {0};\n     qk_circuit_gate(qc, QkGate_X, qargs, NULL);\n     qk_circuit_gate(qc, QkGate_H, qargs, NULL);\n     qk_circuit_gate(qc, QkGate_H, qargs, NULL);\n     qk_circuit_gate(qc, QkGate_Y, qargs, NULL);\n     qk_transpiler_pass_standalone_inverse_cancellation(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_transpiler_pass_standalone_inverse_cancellation(circuit: *mut QkCircuit);
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Runs the Optimize1qGatesDecomposition pass in standalone mode on a circuit.\n\n Optimize1qGatesDecomposition optimizes single-qubit gate sequences by re-synthesizing\n the unitary under the constraints of the target's basis gates and error rates.\n\n The decision of whether to replace the original chain depends on:\n - If the original chain was out of basis.\n - If the original chain was in basis but the replacement has lower error rates.\n - If the original chain is an identity (chain gets removed).\n\n The error is the combined multiplication of the errors of individual gates on the\n qubit it operates on.\n\n @param circuit A pointer to the ``QkCircuit`` object to transform.\n @param target A pointer to the ``QkTarget`` object or a null pointer.\n In the case a null pointer is provided and gate errors are unknown\n the pass will choose the sequence with the least amount of gates,\n and will support all basis gates on its Euler basis set.\n\n # Example\n\n     QkTarget *target = qk_target_new(1);\n     double u_errors[3] = {0., 1e-4, 1e-4};\n     for (int idx = 0; idx < 3; idx++) {\n         QkTargetEntry *u_entry = qk_target_entry_new(QkGate_U);\n         uint32_t qargs[1] = {\n             0,\n         };\n         qk_target_entry_add_property(u_entry, qargs, 1, NAN, u_errors[idx]);\n         qk_target_add_instruction(target, u_entry);\n     }\n\n     // Build circuit\n     QkCircuit *circuit = qk_circuit_new(1, 0);\n     uint32_t qubits[1] = {0};\n     for (int iter = 0; iter < 3; iter++) {\n         qk_circuit_gate(circuit, QkGate_H, qubits, NULL);\n     }\n\n     // Run transpiler pass\n     qk_transpiler_standalone_optimize_1q_sequences(circuit, target);\n\n     // Clean up\n     qk_target_free(target);\n     qk_circuit_free(circuit);\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit`` and\n if ``target`` is not a valid pointer to a ``QkTarget``."]
    pub fn qk_transpiler_standalone_optimize_1q_sequences(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the ``RemoveDiagonalGatesBeforeMeasure`` pass on a circuit.\n\n Transpiler pass to remove diagonal gates (like RZ, T, Z, etc) before\n a measurement. Including diagonal 2Q gates.\n\n @param circuit A pointer to the circuit to run this pass on\n\n # Example\n\n ```c\n     QkCircuit *qc = qk_circuit_new(1, 1);\n     qk_circuit_gate(qc, QkGate_Z, {0}, NULL);\n     qk_circuit_measure(qc, 0, 0);\n     qk_transpiler_pass_standalone_remove_diagonal_gates_before_measure(qc);\n     // ...\n     qk_circuit_free(qc);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_transpiler_pass_standalone_remove_diagonal_gates_before_measure(
        circuit: *mut QkCircuit,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the RemoveIdentityEquivalent transpiler pass on a circuit.\n\n Removes gates whose effect is close to an identity operation up to a global phase\n and up to the specified tolerance. Parameterized gates are not considered by this pass.\n\n For a cutoff fidelity \\f$f\\f$, this pass removes gates whose average\n gate fidelity with respect to the identity is below \\f$f\\f$. Concretely,\n a gate \\f$G\\f$ is removed if \\f$\\bar F < f\\f$ where\n\n \\f[\n bar{F} = \\frac{1 + d F_{\\text{process}}}{1 + d},\\\n\n F_{\\text{process}} = \\frac{|\\mathrm{Tr}(G)|^2}{d^2}\n \\f]\n\n where \\f$d = 2^n\\f$ is the dimension of the gate for \\f$n\\f$ qubits.\n\n @param circuit A pointer to the circuit to run RemoveIdentityEquivalent on. This circuit\n pointed to will be updated with the modified circuit if the pass is able to remove any gates.\n @param target The target for the RemoveIdentityEquivalent pass. If ``approximation_degree`` is set to\n ``NAN`` the tolerance for determining whether an operation is equivalent to\n identity will be set to the reported error rate in the target. Otherwise\n the ``target`` is not used as the tolerance is independent of the target.\n @param approximation_degree The degree to approximate for the equivalence check. This can be a\n floating point value between 0 and 1, or ``NAN``. If the value is 1 this does not\n approximate above the floating point precision. For a value < 1 this is used as a\n scaling factor for the cutoff fidelity. If the value is ``NAN`` this approximates up\n to the fidelity for the gate specified in ``target``.\n\n # Example\n\n ```c\n     QkTarget *target = qk_target_new(5);\n     uint32_t current_num_qubits = qk_target_num_qubits(target);\n     QkTargetEntry *cx_entry = qk_target_entry_new(QkGate_CX);\n     for (uint32_t i = 0; i < current_num_qubits - 1; i++) {\n         uint32_t qargs[2] = {i, i + 1};\n         double inst_error = 0.0090393 * (current_num_qubits - i);\n         double inst_duration = 0.020039;\n         qk_target_entry_add_property(cx_entry, qargs, 2, inst_duration, inst_error);\n     }\n     QkExitCode result_cx = qk_target_add_instruction(target, cx_entry);\n     QkCircuit *qc = qk_circuit_new(4, 0);\n     for (uint32_t i = 0; i < qk_circuit_num_qubits(qc) - 1; i++) {\n         uint32_t qargs[2] = {i, i + 1};\n         for (uint32_t j = 0; j<i+1; j++) {\n             qk_circuit_gate(qc, QkGate_CX, qargs, NULL);\n         }\n     }\n     uint32_t rz_qargs[1] = {1,};\n     double rz_params[1] = {0.,};\n     qk_circuit_gate(qc, QkGate_RZ, rz_qargs, rz_params);\n     qk_transpiler_pass_standalone_remove_identity_equivalent(qc, target, 1.0);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` is not a valid, non-null pointer to a ``QkCircuit`` and ``QkTarget``."]
    pub fn qk_transpiler_pass_standalone_remove_identity_equivalent(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
        approximation_degree: f64,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkSabreLayoutOptions\n\n Build a default sabre layout options object. This builds a sabre layout with ``max_iterations``\n set to 4, both ``num_swap_trials`` and ``num_random_trials`` set to 20, and the seed selected\n by a RNG seeded from system entropy."]
    pub fn qk_sabre_layout_options_default() -> QkSabreLayoutOptions;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the SabreLayout transpiler pass on a circuit.\n\n The SabreLayout pass chooses a layout via an iterative bidirectional routing of the input\n circuit.\n\n Starting with a random initial Layout, the algorithm does a full routing of the circuit to end up with a final_layout.\n This final_layout is then used as the initial_layout for routing the reverse circuit. The algorithm iterates a number\n of times until it finds an initial_layout that reduces full routing cost.\n\n This method exploits the reversibility of quantum circuits, and tries to include global circuit information in the\n choice of initial_layout.\n\n This pass will run both layout and routing and will transform the circuit so that the layout is applied to the input\n (meaning that the output circuit will have ancilla qubits allocated for unused qubits on the coupling map and the\n qubits will be reordered to match the mapped physical qubits) and then routing will be applied. This is done because\n the pass will run parallel seed trials with different random seeds for selecting the random initial layout and then\n selecting the routed output which results in the least number of swap gates needed. This final\n swap calculation is the same as performing a final routing, so it's more efficient to apply it\n after computing it.\n\n This function is multithreaded and will launch a thread pool with threads equal to the number\n of CPUs by default. You can tune the number of threads with the ``RAYON_NUM_THREADS``\n environment variable. For example, setting ``RAYON_NUM_THREADS=4`` would limit the thread pool\n to 4 threads.\n\n # References\n\n [1] Henry Zou and Matthew Treinish and Kevin Hartman and Alexander Ivrii and Jake Lishman.\n \"LightSABRE: A Lightweight and Enhanced SABRE Algorithm\"\n [arXiv:2409.08368](https://doi.org/10.48550/arXiv.2409.08368)\n\n [2] Li, Gushu, Yufei Ding, and Yuan Xie. \"Tackling the qubit mapping problem\n for NISQ-era quantum devices.\" ASPLOS 2019.\n [`arXiv:1809.02573](https://arxiv.org/pdf/1809.02573.pdf)\n\n @param circuit A pointer to the circuit to run SabreLayout on. The circuit\n     is modified in place and the original circuit's allocations are freed by this function.\n @param target A pointer to the target to run SabreLayout on\n @param options A pointer to the options for SabreLayout\n\n @return The transpile layout that describes the layout and output permutation caused\n     by the pass\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` is not a valid, non-null pointer to a ``QkCircuit`` and ``QkTarget``."]
    pub fn qk_transpiler_pass_standalone_sabre_layout(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
        options: *const QkSabreLayoutOptions,
    ) -> *mut QkTranspileLayout;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the Split2QUnitaries transpiler pass\n\n @param circuit A mutable pointer to the circuit to run Split2QUnitaries on. This will be\n     replaced with the new circuit if any gates are optimized and the original will be freed.\n @param requested_fidelity Allowed tolerance for splitting two-qubit unitaries and gate decompositions.\n @param split_swaps Whether to attempt to split swap gates, resulting in a permutation of the qubits.\n\n @return If any swap equivalent unitaries are split this function returns a pointer to a ``TranspileLayout``\n     that contains the permutation induced by this circuit optimization. If no swap equivalent\n     unitaries are split this will be a null pointer.\n\n # Example\n\n ```c\n QkCircuit *qc = qk_circuit_new(4, 0);\n for (uint32_t i = 0; i < qk_circuit_num_qubits(qc) - 1; i++) {\n     uint32_t qargs[2] = {i, i + 1};\n     for (uint32_t j = 0; j<i+1; j++) {\n         qk_circuit_gate(qc, QkGate_CX, qargs, NULL);\n     }\n }\n QkTranspileLayout *result = qk_transpiler_pass_standalone_split_2q_unitaries(qc, 1e-12, true)\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` is not a valid, non-null pointer to a ``QkCircuit``."]
    pub fn qk_transpiler_pass_standalone_split_2q_unitaries(
        circuit: *mut QkCircuit,
        requested_fidelity: f64,
        split_swaps: bool,
    ) -> *mut QkTranspileLayout;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the UnitarySynthesis transpiler pass.\n\n The UnitarySynthesis transpiler pass will synthesize any UnitaryGates in the circuit into gates\n available in the target.\n\n Right now from C this pass only supports 1 and 2 qubit UnitaryGates. Larger unitary matrices\n will be supported in a future release.\n\n @param circuit A pointer to the circuit to run UnitarySynthesis on\n @param target A pointer to the target to run UnitarySynthesis on\n @param min_qubits The minimum number of qubits in the unitary to synthesize. If the unitary\n        is less than the specified number of qubits it will not be synthesized.\n @param approximation_degree heuristic dial used for circuit approximation\n        (1.0=no approximation, 0.0=maximal approximation). Approximation can\n        make the synthesized circuit cheaper at the cost of straying from\n        the original unitary. If NAN, the target approximation is based on gate fidelities\n        in the ``target``.\n\n # Example\n\n ```c\n     QkTarget *target = qk_target_new(2);\n     uint32_t current_num_qubits = qk_target_num_qubits(target);\n     QkTargetEntry *cx_entry = qk_target_entry_new(QkGate_CX);\n     for (uint32_t i = 0; i < current_num_qubits - 1; i++) {\n         uint32_t qargs[2] = {i, i + 1};\n         double inst_error = 0.0090393 * (current_num_qubits - i);\n         double inst_duration = 0.020039;\n         qk_target_entry_add_property(cx_entry, qargs, 2, inst_duration, inst_error);\n     }\n     QkExitCode result_cx = qk_target_add_instruction(target, cx_entry);\n     QkCircuit *qc = qk_circuit_new(2, 0);\n     QkComplex64 c0 = {0., 0.};\n     QkComplex64 c1 = {1., 0.};\n     QkComplex64 unitary[16] = {c1, c0, c0, c0,  // row 0\n                                c0, c1, c0, c0,  // row 1\n                                c0, c0, c1, c0,  // row 2\n                                c0, c0, c0, c1}; // row 3\n     uint32_t qargs[2] = {0, 1};\n     qk_circuit_unitary(qc, unitary, qargs, 2, false);\n     qk_transpiler_pass_standalone_unitary_synthesis(qc, target, 0, 1.0);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` is not a valid, non-null pointer to a ``QkCircuit`` and ``QkTarget``."]
    pub fn qk_transpiler_pass_standalone_unitary_synthesis(
        circuit: *mut QkCircuit,
        target: *const QkTarget,
        min_qubits: usize,
        approximation_degree: f64,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkVF2LayoutResult\n Check whether a result was found.\n\n @param layout a pointer to the layout\n\n @returns ``true`` if the ``qk_transpiler_pass_standalone_vf2_layout()`` run found a layout\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkVF2LayoutResult``."]
    pub fn qk_vf2_layout_result_has_match(layout: *const QkVF2LayoutResult) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkVF2LayoutResult\n Get the number of virtual qubits in the layout.\n\n @param layout a pointer to the layout\n\n @returns The number of virtual qubits in the layout\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkVF2LayoutResult``. The result must have a layout found."]
    pub fn qk_vf2_layout_result_num_qubits(layout: *const QkVF2LayoutResult) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkVF2LayoutResult\n Get the physical qubit for a given virtual qubit\n\n @param layout a pointer to the layout\n @param qubit the virtual qubit to get the physical qubit of\n\n @returns The physical qubit mapped to by the specified virtual qubit\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkVF2LayoutResult``. Also qubit must be a valid qubit for the circuit and\n there must be a result found."]
    pub fn qk_vf2_layout_result_map_virtual_qubit(
        layout: *const QkVF2LayoutResult,
        qubit: u32,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkVF2LayoutResult\n Free a ``QkVF2LayoutResult`` object\n\n @param layout a pointer to the layout to free\n\n # Example\n\n     QkCircuit *qc = qk_circuit_new(1, 0);\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a ``QkVF2Layout``."]
    pub fn qk_vf2_layout_result_free(layout: *mut QkVF2LayoutResult);
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspilerPasses\n Run the VF2Layout pass on a circuit.\n\n VF2Layout is a pass for choosing a layout of a circuit onto a connectivity graph as\n a subgraph isomorphism problem solved by VF2.\n\n If this pass finds a solution that means there is a \"perfect layout\" and that no\n further swap mapping or routing is needed. However, there is not always a possible\n solution, or a solution might exist but it is not found within the limits specified\n when the pass is called.\n\n By default, this pass will construct a heuristic scoring map based on the error rates\n in the provided ``target`` argument. The function will continue searching for layouts\n and use the heuristic scoring to return the layout which will run with the best estimated\n fidelity.\n\n @param circuit A pointer to the circuit to run VF2Layout on\n @param target A pointer to the target to run the VF2Layout pass on\n @param strict_direction If true the pass will consider the edge direction in the\n     connectivity described in the ``target``. Typically setting this to ``false``\n     is desirable as an undirected search has more degrees of freedom and is more likely\n     to find a layout (or a better layout if there are multiple choices) and correcting\n     directionality is a simple operation for later transpilation stages.\n @param call_limit The number of state visits to attempt in each execution of the VF2 algorithm.\n     If the value is set to a negative value the VF2 algorithm will run without any limit.\n @param time_limit The total time in seconds to run for ``VF2Layout``. This is checked after\n     each layout search so it is not a hard time limit, but a soft limit that when checked\n     if the set time has elapsed the function will return the best layout it has found so\n     far. Set this to a value less than or equal to 0.0 to run without any time limit.\n @param max_trials The maximum number of trials to run the VF2 algorithm to try and find\n     layouts. If the value is negative this will be treated as unbounded which means the\n     algorithm will run until all possible layouts are scored. If the value is 0 the number\n     of trials will be limited based on the number of edges in the interaction or the coupling\n     graph (whichever is larger).\n\n @return QkVF2LayoutResult A pointer to a result object that contains the\n results of the pass. This object is heap allocated and will need to be freed with the\n ``qk_vf2_layout_result_free()`` function.\n\n # Example\n\n ```c\n     QkTarget *target = qk_target_new(5);\n     uint32_t current_num_qubits = qk_target_num_qubits(target);\n     QkTargetEntry *cx_entry = qk_target_entry_new(QkGate_CX);\n     for (uint32_t i = 0; i < current_num_qubits - 1; i++) {\n         uint32_t qargs[2] = {i, i + 1};\n         double inst_error = 0.0090393 * (current_num_qubits - i);\n         double inst_duration = 0.020039;\n         qk_target_entry_add_property(cx_entry, qargs, 2, inst_duration, inst_error);\n     }\n     QkExitCode result_cx = qk_target_add_instruction(target, cx_entry);\n     QkCircuit *qc = qk_circuit_new(4, 0);\n     for (uint32_t i = 0; i < qk_circuit_num_qubits(qc) - 1; i++) {\n         uint32_t qargs[2] = {i, i + 1};\n         for (uint32_t j = 0; j<i+1; j++) {\n             qk_circuit_gate(qc, QkGate_CX, qargs, NULL);\n         }\n     }\n     QkVF2LayoutResult *layout_result = qk_transpiler_pass_standalone_vf2_layout(qc, target, false, -1, NAN, -1);\n     qk_vf2_layout_result_free(layout_result);\n ```\n\n # Safety\n\n Behavior is undefined if ``circuit`` or ``target`` is not a valid, non-null pointer to a ``QkCircuit`` and ``QkTarget``."]
    pub fn qk_transpiler_pass_standalone_vf2_layout(
        circuit: *const QkCircuit,
        target: *const QkTarget,
        strict_direction: bool,
        call_limit: i64,
        time_limit: f64,
        max_trials: i64,
    ) -> *mut QkVF2LayoutResult;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Construct a new ``QkTarget`` with the given number of qubits.\n The number of qubits is bound to change if an instruction is added with properties\n that apply to a collection of qargs in which any index is higher than the specified\n number of qubits\n\n @param num_qubits The number of qubits the ``QkTarget`` will explicitly support.\n\n @return A pointer to the new ``QkTarget``\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n ```\n"]
    pub fn qk_target_new(num_qubits: u32) -> *mut QkTarget;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the number of qubits of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The number of qubits this target can use.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     uint32_t num_qubits = qk_target_num_qubits(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_num_qubits(target: *const QkTarget) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the dt value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The dt value of this ``QkTarget`` or ``NAN`` if not assigned.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     qk_target_set_dt(target, 10e-9);\n     double dt = qk_target_dt(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_dt(target: *const QkTarget) -> f64;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the granularity value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The ``granularity`` value of this ``QkTarget``.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 1\n     uint32_t granularity = qk_target_granularity(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_granularity(target: *const QkTarget) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the ``min_length`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The ``min_length`` value of this ``QkTarget``.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 1\n     size_t min_length = qk_target_min_length(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_min_length(target: *const QkTarget) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the ``pulse_alignment`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The ``pulse_alignment`` value of this ``QkTarget``.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 1\n     uint32_t pulse_alignment = qk_target_pulse_alignment(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_pulse_alignment(target: *const QkTarget) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the ``acquire_alignment`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The ``acquire_alignment`` value of this ``QkTarget``.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 0\n     uint32_t acquire_alignment = qk_target_pulse_alignment(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_acquire_alignment(target: *const QkTarget) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Sets the dt value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n @param dt The ``dt`` value for the system time resolution of input.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n\n ```c\n     QkTarget *target = qk_target_new(5);\n     double dt = qk_target_set_dt(target, 10e-9);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_set_dt(target: *mut QkTarget, dt: f64) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Sets the ``granularity`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n @param granularity The value for the minimum pulse gate resolution in\n     units of ``dt``.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 1\n     qk_target_set_granularity(target, 2);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_set_granularity(target: *mut QkTarget, granularity: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Sets the ``min_length`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n @param min_length The minimum pulse gate length value in units of ``dt``.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 1\n     qk_target_set_min_length(target, 3);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_set_min_length(target: *mut QkTarget, min_length: u32) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the ``pulse_alignment`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n @param pulse_alignment value representing a time resolution of gate.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 1\n     qk_target_set_pulse_alignment(target, 4);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_set_pulse_alignment(target: *mut QkTarget, pulse_alignment: u32)
    -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Sets the ``acquire_alignment`` value of this ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n @param acquire_alignment value representing a time resolution of measure instruction\n     starting time.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     // The value defaults to 0\n     qk_target_set_acquire_alignment(target, 5);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_set_acquire_alignment(
        target: *mut QkTarget,
        acquire_alignment: u32,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Creates a copy of the ``QkTarget``.\n\n @param target A pointer to the ``QkTarget`` to copy.\n\n @return A pointer to the new copy of the ``QkTarget``.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     QkTargetEntry *entry = qk_target_entry_new(QkGate_CX);\n     uint32_t qargs[2] = {0, 1};\n     qk_target_entry_add_property(entry, qargs, 2, 0.0, 0.1);\n     QkExitCode result = qk_target_add_instruction(target, entry);\n\n     QkTarget *copied = qk_target_copy(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_copy(target: *mut QkTarget) -> *mut QkTarget;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Free the ``QkTarget``.\n\n @param target A pointer to the ``QkTarget`` to free.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     qk_target_free(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_free(target: *mut QkTarget);
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Creates an entry to the ``QkTarget`` based on a ``QkGate`` instance.\n\n @param operation The ``QkGate`` whose properties this target entry defines. If the ``QkGate``\n takes parameters (which can be checked with ``qk_gate_num_params``) it will be added as a\n an instruction on the target which accepts any parameter value. If the gate only accepts a\n fixed parameter value you can use ``qk_target_entry_new_fixed`` instead.\n\n @return A pointer to the new ``QkTargetEntry``.\n\n # Example\n ```c\n     QkTargetEntry *entry = qk_target_entry_new(QkGate_H);\n ```"]
    pub fn qk_target_entry_new(operation: QkGate) -> *mut QkTargetEntry;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Creates a new entry for adding a measurement instruction to a ``QkTarget``.\n\n @return A pointer to the new ``QkTargetEntry`` for a measurement instruction.\n\n # Example\n ```c\n     QkTargetEntry *entry = qk_target_entry_new_measure();\n     // Add fixed duration and error rates from qubits at index 0 to 4.\n     for (uint32_t i = 0; i < 5; i++) {\n         // Measure is a single qubit instruction\n         uint32_t qargs[1] = {i};\n         qk_target_entry_add_property(entry, qargs, 1, 1.928e-10, 7.9829e-11);\n     }\n\n     // Add the entry to a target with 5 qubits\n     QkTarget *measure_target = qk_target_new(5);\n     qk_target_add_instruction(measure_target, entry);\n ```"]
    pub fn qk_target_entry_new_measure() -> *mut QkTargetEntry;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Creates a new entry for adding a reset instruction to a ``QkTarget``.\n\n @return A pointer to the new ``QkTargetEntry`` for a reset instruction.\n\n # Example\n ```c\n     QkTargetEntry *entry = qk_target_entry_new_reset();\n     // Add fixed duration and error rates from qubits at index 0 to 2.\n     for (uint32_t i = 0; i < 3; i++) {\n         // Reset is a single qubit instruction\n         uint32_t qargs[1] = {i};\n         qk_target_entry_add_property(entry, qargs, 1, 1.2e-11, 5.9e-13);\n     }\n\n     // Add the entry to a target with 3 qubits\n     QkTarget *reset_target = qk_target_new(3);\n     qk_target_add_instruction(reset_target, entry);\n ```"]
    pub fn qk_target_entry_new_reset() -> *mut QkTargetEntry;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Creates an entry in the ``QkTarget`` based on a ``QkGate`` instance with\n no parameters.\n\n @note Adding a ``QkGate`` with regular parameters is not currently supported.\n\n @param operation The ``QkGate`` whose properties this target entry defines.\n @param params A pointer to the parameters that the instruction is calibrated for.\n\n @return A pointer to the new ``QkTargetEntry``.\n\n # Example\n ```c\n     double crx_params[1] = {3.14};\n     QkTargetEntry *entry = qk_target_entry_new_fixed(QkGate_CRX, crx_params);\n ```\n\n # Safety\n\n The ``params`` type is expected to be a pointer to an array of ``double`` where the length\n matches the expectations of the ``QkGate``. If the array is insufficiently long the\n behavior of this function is undefined as this will read outside the bounds of the array.\n It can be a null pointer if there are no params for a given gate. You can check\n ``qk_gate_num_params`` to determine how many qubits are required for a given gate."]
    pub fn qk_target_entry_new_fixed(operation: QkGate, params: *mut f64) -> *mut QkTargetEntry;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Retrieves the number of properties stored in the target entry.\n\n @param entry The pointer to the mapping object.\n\n @return The number of properties in the ``QkTargetEntry``.\n\n # Example\n ```c\n     // Create an entry for an H gate\n     QkTargetEntry *entry = qk_target_entry_new(QkGate_H);\n     size_t props_size = qk_target_entry_num_properties(entry);\n ```\n\n # Safety\n\n The behavior is undefined if ``entry`` is not a valid,\n non-null pointer to a ``QkTargetEntry`` object."]
    pub fn qk_target_entry_num_properties(entry: *const QkTargetEntry) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Frees the entry.\n\n @note An entry pointer will be freed when added to a ``QkTarget`` via\n ``qk_target_add_instruction``, this function is only meant to be used\n alternatively if an entry is never added to a ``QkTarget`` instance.\n\n @param entry The pointer to the mapping object to be freed.\n\n # Example\n ```c\n     QkTargetEntry *entry = qk_target_entry_new(QkGate_H);\n     qk_target_entry_free(entry);\n ```\n\n # Safety\n\n The behavior is undefined if ``entry`` is not a valid,\n non-null pointer to a ``QkTargetEntry`` object."]
    pub fn qk_target_entry_free(entry: *mut QkTargetEntry);
}
unsafe extern "C" {
    #[doc = " @ingroup QkTargetEntry\n Adds an instruction property instance based on its assigned qargs.\n\n @param entry The pointer to the entry object.\n @param qargs A pointer to the array of ``uint32_t`` qubit indices to add the\n     gate on, can be a null pointer to check for global properties.\n @param num_qubits The length of the qargs array.\n @param duration The instruction's duration in seconds on the specific set of\n     qubits.\n @param error The instruction's average error rate on the specific set of qubits.\n\n # Example\n ```c\n     QkTargetEntry *entry = qk_target_entry_new(QkGate_CX);\n     uint32_t qargs[2] = {0, 1};\n     qk_target_entry_add_property(entry, qargs, 2, 0.0, 0.1);\n ```\n\n # Safety\n\n The behavior is undefined if ``entry`` is not a valid, non-null pointer\n to a ``QkTargetEntry`` object."]
    pub fn qk_target_entry_add_property(
        entry: *mut QkTargetEntry,
        qargs: *mut u32,
        num_qubits: u32,
        duration: f64,
        error: f64,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Adds a gate to the ``QkTarget`` through a ``QkTargetEntry``.\n\n @param target A pointer to the ``QkTarget``.\n @param target_entry A pointer to the ``QkTargetEntry``. The pointer\n gets freed when added to the ``QkTarget``.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     QkTargetEntry *entry = qk_target_entry_new(QkGate_CX);\n     uint32_t qargs[2] = {0, 1};\n     qk_target_entry_add_property(entry, qargs, 2, 0.0, 0.1);\n     QkExitCode result = qk_target_add_instruction(target, entry);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``.\n\n Behavior is undefined if ``entry`` is not a valid, non-null pointer to a ``QkTargetEntry``."]
    pub fn qk_target_add_instruction(
        target: *mut QkTarget,
        target_entry: *mut QkTargetEntry,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Modifies the properties of a gate in the ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n @param instruction The instruction to modify.\n @param qargs The pointer to the array of ``uint32_t`` values to use as\n qargs. Can be ``NULL`` if global.\n @param num_qubits The number of qubits of the instruction..\n @param duration The instruction's duration in seconds on the specific set of\n     qubits.\n @param error The instruction's average error rate on the specific set of qubits.\n\n @return ``QkExitCode`` specifying if the operation was successful.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     double params[1] = {3.1415};\n     QkTargetEntry *entry = qk_target_entry_new_fixed(QkGate_CRX, params);\n     uint32_t qargs[2] = {0, 1};\n     qk_target_entry_add_property(entry, qargs, 2, 0.0, 0.1);\n     qk_target_add_instruction(target, entry);\n\n     qk_target_update_property(target, QkGate_CRX, qargs, 2, 0.0012, 1.1);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``.\n\n The ``qargs`` type is expected to be a pointer to an array of ``uint32_t`` where the length\n matches is specified by ``num_qubits`` and has to match the expectation of the gate. If the\n array is insufficiently long the behavior of this function is undefined as this will read\n outside the bounds of the array. It can be a null pointer if there are no qubits for\n a given gate. You can check ``qk_gate_num_qubits`` to determine how many qubits are required\n for a given gate."]
    pub fn qk_target_update_property(
        target: *mut QkTarget,
        instruction: QkGate,
        qargs: *mut u32,
        num_qubits: u32,
        duration: f64,
        error: f64,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTarget\n Returns the number of instructions tracked by a ``QkTarget``.\n\n @param target A pointer to the ``QkTarget``.\n\n @return The length of the target.\n\n # Example\n ```c\n     QkTarget *target = qk_target_new(5);\n     QkTargetEntry *target_entry = qk_target_entry_new(QkGate_H);\n     qk_target_add_instruction(target, target_entry);\n\n     size_t num_instructions = qk_target_num_instructions(target);\n ```\n\n # Safety\n\n Behavior is undefined if ``QkTarget`` is not a valid, non-null pointer to a ``QkTarget``."]
    pub fn qk_target_num_instructions(target: *const QkTarget) -> usize;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspiler\n\n Generate transpiler options defaults\n\n This function generates a QkTranspileOptions with the default settings\n This currently is ``optimization_level`` 2, no seed, and no approximation."]
    pub fn qk_transpiler_default_options() -> QkTranspileOptions;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspiler\n Transpile a single circuit.\n\n The Qiskit transpiler is a quantum circuit compiler that rewrites a given\n input circuit to match the constraints of a QPU and optimizes the circuit\n for execution. This function should only be used with circuits constructed\n using Qiskit's C API. It makes assumptions on the circuit only using features exposed via C,\n if you are in a mixed Python and C environment it is typically better to invoke the transpiler\n via Python.\n\n This function is multithreaded internally and will launch a thread pool\n with threads equal to the number of CPUs reported by the operating system by default.\n This will include logical cores on CPUs with simultaneous multithreading. You can tune the\n number of threads with the ``RAYON_NUM_THREADS`` environment variable. For example, setting\n ``RAYON_NUM_THREADS=4`` would limit the thread pool to 4 threads.\n\n @param circuit A pointer to the circuit to run the transpiler on.\n @param target A pointer to the target to compile the circuit for.\n @param options A pointer to an options object that defines user options. If this is a null\n   pointer the default values will be used. See ``qk_transpile_default_options``\n   for more details on the default values.\n @param result A pointer to the memory location of the transpiler result. On a successful\n   execution (return code 0) the output of the transpiler will be written to the pointer. The\n   members of the result struct are owned by the caller and you are responsible for freeing\n   the members using the respective free functions.\n @param error A pointer to a pointer with an nul terminated string with an error description.\n   If the transpiler fails a pointer to the string with the error description will be written\n   to this pointer. That pointer needs to be freed with ``qk_str_free```. This can be a null\n   pointer in which case the error will not be written out.\n\n @returns The return code for the transpiler, ``QkExitCode_Success`` means success and all\n   other values indicate an error.\n\n # Safety\n\n Behavior is undefined if ``circuit``, ``target``, or ``result``, are not valid, non-null\n pointers to a ``QkCircuit``, ``QkTarget``, or ``QkTranspileResult`` respectively.\n ``options`` must be a valid pointer a to a ``QkTranspileOptions`` or ``NULL`.\n ``error`` must be a valid pointer to a ``char`` pointer or ``NULL``."]
    pub fn qk_transpile(
        qc: *const QkCircuit,
        target: *const QkTarget,
        options: *const QkTranspileOptions,
        result: *mut QkTranspileResult,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> QkExitCode;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspileLayout\n Return the number of qubits in the input circuit to the transpiler.\n\n @param layout A pointer to the ``QkTranspileLayout``.\n\n @return The number of input qubits\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkTranspileLayout``."]
    pub fn qk_transpile_layout_num_input_qubits(layout: *const QkTranspileLayout) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspileLayout\n Return the number of qubits in the output circuit from the transpiler.\n\n @param layout A pointer to the ``QkTranspileLayout``.\n\n @return The number of output qubits\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkTranspileLayout``."]
    pub fn qk_transpile_layout_num_output_qubits(layout: *const QkTranspileLayout) -> u32;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspileLayout\n Query the initial layout of a ``QkTranspileLayout``.\n\n The output array from this function represents the mapping from the virutal qubits in the\n original input circuit to the physical qubit in the output circuit. The\n index in the array is the virtual qubit and the value is the physical qubit. For example an\n output array of:\n\n ```\n [1, 0, 2]\n ```\n\n indicates that the layout maps virtual qubit 0 -> physical qubit 1, virtual qubit 1 -> physical\n qubit -> 0, and virtual qubit 2 -> physical qubit 2.\n\n @param layout A pointer to the ``QkTranspileLayout``.\n @param filter_ancillas If set to true the output array will not include any indicies for any\n ancillas added by the transpiler.\n @param initial_layout A pointer to the array where this function will write the initial layout\n to. This must have sufficient space for the full array which will either be\n ``qk_transpile_layout_num_input_qubits()`` or ``qk_transpile_layout_num_output_qubits()`` for\n ``filter_ancillas`` being true or false respectively.\n\n @returns True if there was a initial_layout written to ``initial_layout`` and false if there\n is no initial layout.\n\n # Safety\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkTranspileLayout``. ``initial_layout`` must be a valid, non-null pointer with a large enough\n allocation to store the size necessary for the initial layout. If ``filter_ancillas`` is true\n this will be number of input qubits (which can be checked with\n ``qk_transpile_layout_num_input_qubits()``) or the number of output qubits if ``filter_ancillas``\n is false (which can be queried with ``qk_transpile_layout_num_output_qubits()``)."]
    pub fn qk_transpile_layout_initial_layout(
        layout: *const QkTranspileLayout,
        filter_ancillas: bool,
        initial_layout: *mut u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspileLayout\n Query the output permutation of a ``QkTranspileLayout``\n\n The output array from this function represents the permutation induced by the transpiler where\n the index indicates the qubit at the start of the circuit and the value is the position of the\n qubit at the end of the circuit. For example an output array of:\n\n ```\n [1, 2, 0]\n ```\n\n indicates that qubit 0 from the start of the circuit is at qubit 1 at the end of the circuit,\n 1 -> 2, and 2 -> 0.\n\n @param layout A pointer to the ``QkTranspileLayout``.\n @param output_permutation A pointer to the array where this function will write the output permutation\n to. This must have sufficient space for the output which will be the number of output qubits in\n the layout. This can be queried with ``qk_transpile_layout_num_output_qubits``.\n\n @returns True if there is an output permutation that was written to ``output_permutation``\n false if the ``QkTranspileLayout`` does not contain an output permutation.\n\n # Safety\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkTranspileLayout``. ``output_permutation`` must be a valid, non-null pointer with a large enough\n allocation to store the size necessary for the output_permutation. This will always be the number\n of output qubits in the ``QkTranspileLayout`` which can be queried with\n ``qk_transpile_layout_num_output_qubits()``."]
    pub fn qk_transpile_layout_output_permutation(
        layout: *const QkTranspileLayout,
        output_permutation: *mut u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspileLayout\n Query the final layout of a ``QkTranspileLayout``\n\n The output array represents the mapping from the virtual qubit in the original input circuit to\n the physical qubit at the end of the transpile circuit that has that qubit's state. The array\n index represents the virtual qubit and the value represents the physical qubit at the end of\n the transpiled circuit which has that virtual qubit's state. For example, an output array of:\n\n ```\n [2, 0, 1]\n ```\n\n indicates that virtual qubit 0's state in the original circuit is on\n physical qubit 2 at the end of the transpiled circuit, 1 -> 0, and 2 -> 1.\n\n @param layout A pointer to the ``QkTranspileLayout``.\n @param filter_ancillas If set to true the output array will not include any indicies for any\n ancillas added by the transpiler.\n @param final_layout A pointer to the array where this function will write the final layout to.\n This must have sufficient space for the output which will either be the number of input or\n output qubits depending on the value of filter_ancillas.\n\n # Safety\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a\n ``QkTranspileLayout``. ``final_layout`` must be a valid, non-null pointer with a large enough\n allocation to store the size necessary for the final layout. If ``filter_ancillas`` is true\n this will be number of input qubits (which can be checked with\n ``qk_transpile_layout_num_input_qubits()``) or the number of output qubits if ``filter_ancillas``\n is false (which can be queried with ``qk_transpile_layout_num_output_qubits()``)."]
    pub fn qk_transpile_layout_final_layout(
        layout: *const QkTranspileLayout,
        filter_ancillas: bool,
        final_layout: *mut u32,
    );
}
unsafe extern "C" {
    #[doc = " @ingroup QkTranspileLayout\n Free a ``QkTranspileLayout`` object\n\n @param layout a pointer to the layout to free\n\n # Safety\n\n Behavior is undefined if ``layout`` is not a valid, non-null pointer to a ``QkTranspileLayout``."]
    pub fn qk_transpile_layout_free(layout: *mut QkTranspileLayout);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
